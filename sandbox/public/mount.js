/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../index.js":
/*!*******************!*\
  !*** ../index.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"useEffect\": () => (/* binding */ useEffect),\n/* harmony export */   \"useRef\": () => (/* binding */ useRef),\n/* harmony export */   \"useState\": () => (/* binding */ useState)\n/* harmony export */ });\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib.js */ \"../lib.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\nvar useState = _lib_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].useState,\n    useEffect = _lib_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].useEffect,\n    useRef = _lib_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].useRef;\n\n\n//# sourceURL=webpack://sandbox/../index.js?");

/***/ }),

/***/ "../lib.js":
/*!*****************!*\
  !*** ../lib.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar _excluded = [\"key\", \"ref\"],\n    _excluded2 = [\"key\", \"ref\"];\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/**\n *\n * @type {Object<Fiber>}\n */\nvar fiberMap = {};\nvar normallyEmptyAppendedNodeArray = [];\nwindow.HookInternals = {\n  fiberMap: fiberMap,\n  normallyEmptyAppendedNodeArray: normallyEmptyAppendedNodeArray\n};\nvar CONTAINER_ID_KEY = 'Hook$ContainerId';\nvar COMPONENT_TYPE_KEY = 'Hook$ComponentType';\n/**\n *\n * @param {function} Component\n * @param {{}} props\n * @returns {Fiber}\n * @constructor\n */\n\nfunction Fiber(Component, props) {\n  this.Component = Component;\n  this.props = props;\n  this.hooks = [];\n  this.virtualNode = null;\n}\n/**\n *\n * @param {string|function} type\n * @param {{}} props\n * @param {string|null} key\n * @param {RefHook|null} ref\n * @return {VirtualNode}\n * @constructor\n */\n\n\nfunction VirtualNode(type, props, key, ref) {\n  var _this = this;\n\n  this.type = type;\n  this.props = props;\n  this.key = key;\n  this.ref = ref;\n  this.fiber = null;\n  this.parent = null;\n  this.children = [];\n  this.path = [];\n  this.resolvePath = null;\n  this.htmlNode = null;\n\n  this.setHtmlNode = function (htmlNode) {\n    _this.htmlNode = htmlNode;\n\n    if (_this.ref instanceof RefHook) {\n      _this.ref.current = htmlNode;\n    }\n  };\n}\n/**\n *\n * @param {*} current\n * @constructor\n */\n\n\nfunction RefHook(current) {\n  this.current = current;\n}\n/**\n *\n * @param {*} value\n * @param {function} setValue\n * @return {StateHook}\n * @constructor\n */\n\n\nfunction StateHook(value, setValue) {\n  this.value = value;\n  this.setValue = setValue;\n}\n\nvar EFFECT_NONE = 0;\nvar EFFECT_ALWAYS = 1;\nvar EFFECT_LAZY = 2;\nvar EFFECT_DEPS = 3;\nvar EFFECT_DEPS_CHANGED = 4;\n/**\n *\n * @param {function} callback\n * @param {[]?} deps\n * @param {function?} lastDestroy\n * @return {EffectHook}\n * @constructor\n */\n\nfunction EffectHook(callback, deps, lastDestroy) {\n  this.tag = EFFECT_NONE;\n  this.callback = callback;\n  this.deps = deps;\n  this.destroy = undefined;\n  this.lastDestroy = lastDestroy;\n}\n/**\n *\n * @param {VirtualNode|null} parent\n * @param {[]} routeFromParent\n * @param {VirtualNode} current\n * @return {AppendInfo}\n * @constructor\n */\n\n\nfunction AppendInfo(parent, routeFromParent, current) {\n  this.parent = parent;\n  this.routeFromParent = routeFromParent;\n  this.current = current;\n}\n/**\n *\n * @type {Fiber|null}\n */\n\n\nvar currentlyRenderingFiber = null;\nvar currentHookIndex = -1;\nvar containerIdInc = 0;\n\nfunction getContainerId(root) {\n  if (!hasOwnProperty(root, CONTAINER_ID_KEY)) {\n    root[CONTAINER_ID_KEY] = '~' + ++containerIdInc;\n  }\n\n  return root[CONTAINER_ID_KEY];\n}\n\nvar componentTypeInc = 0;\n\nfunction getComponentType(Component) {\n  if (!hasOwnProperty(Component, COMPONENT_TYPE_KEY)) {\n    Component[COMPONENT_TYPE_KEY] = '$' + ++componentTypeInc;\n  }\n\n  return Component[COMPONENT_TYPE_KEY];\n}\n\nvar componentTempPathDec = 0;\n\nfunction generateTemporaryPath() {\n  return [--componentTempPathDec];\n}\n\nfunction stringifyPath(path) {\n  return path.join('/');\n}\n\nfunction prepareCurrentlyRendering(fiber) {\n  currentlyRenderingFiber = fiber;\n  currentHookIndex = -1;\n}\n\nfunction flushCurrentlyRendering() {\n  currentlyRenderingFiber = null;\n  currentHookIndex = -1;\n}\n\nfunction findFiber(path) {\n  var pathString = stringifyPath(path);\n\n  if (hasOwnProperty(fiberMap, pathString)) {\n    return fiberMap[pathString];\n  }\n\n  return null;\n}\n\nfunction linkFiber(path, fiber) {\n  fiberMap[stringifyPath(path)] = fiber;\n}\n\nfunction unlinkFiber(path) {\n  delete fiberMap[stringifyPath(path)];\n}\n\nfunction resolveCurrentlyRunningFiber() {\n  if (currentlyRenderingFiber === null) {\n    throw new Error('Cannot call hook from outside of the Hook component');\n  }\n\n  return currentlyRenderingFiber;\n}\n\nfunction useRef(initialValue) {\n  var fiber = resolveCurrentlyRunningFiber();\n  currentHookIndex++;\n\n  if (fiber.hooks.length > currentHookIndex) {\n    return fiber.hooks[currentHookIndex];\n  }\n\n  var hook = new RefHook(initialValue);\n  fiber.hooks.push(hook);\n  return hook;\n}\n\nfunction useState(initialValue) {\n  var fiber = resolveCurrentlyRunningFiber();\n  currentHookIndex++;\n\n  if (fiber.hooks.length > currentHookIndex) {\n    var _hook = fiber.hooks[currentHookIndex];\n    return [_hook.value, _hook.setValue];\n  }\n\n  var hook = new StateHook(initialValue, function (value) {\n    var newValue;\n\n    if (typeof value === 'function') {\n      newValue = value(hook.value);\n    } else {\n      newValue = value;\n    }\n\n    if (newValue !== hook.value) {\n      hook.value = newValue;\n      updateComponent(fiber.virtualNode);\n    }\n  });\n  fiber.hooks.push(hook);\n  return [hook.value, hook.setValue];\n}\n\nfunction useEffect(callback) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var fiber = resolveCurrentlyRunningFiber();\n  currentHookIndex++;\n\n  if (fiber.hooks.length > currentHookIndex) {\n    /**\n     * @type {EffectHook}\n     */\n    var currentHook = fiber.hooks[currentHookIndex];\n\n    if (!(deps === null && currentHook.deps === null || deps.length === currentHook.deps.length)) {\n      throw new Error('useEffect: Dependencies must be size-fixed');\n    }\n\n    var effectTag = getEffectTag(deps, currentHook.deps);\n\n    if (effectTag === EFFECT_LAZY) {\n      return;\n    }\n\n    if (effectTag === EFFECT_DEPS) {\n      currentHook.tag = effectTag;\n      return;\n    }\n\n    if (effectTag === EFFECT_ALWAYS || effectTag === EFFECT_DEPS_CHANGED) {\n      var newHook = new EffectHook(callback, deps, currentHook.destroy);\n      newHook.tag = effectTag;\n      fiber.hooks[currentHookIndex] = newHook;\n      return;\n    }\n\n    return;\n  }\n\n  var hook = new EffectHook(callback, deps);\n  hook.tag = getEffectTag(deps);\n  fiber.hooks.push(hook);\n}\n\nfunction getEffectTag(deps) {\n  var lastDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // Always\n  if (deps === null) {\n    return EFFECT_ALWAYS;\n  } // Lazy\n\n\n  if (deps.length === 0) {\n    return EFFECT_LAZY;\n  } // Deps\n\n\n  if (lastDeps === false || compareArrays(deps, lastDeps)) {\n    return EFFECT_DEPS;\n  } // DepsChanged\n\n\n  {\n    return EFFECT_DEPS_CHANGED;\n  }\n}\n\nfunction compareArrays(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n *\n * @param {EffectHook} effectHook\n */\n\n\nfunction mountEffectHook(effectHook) {\n  effectHook.destroy = effectHook.callback();\n}\n/**\n *\n * @param {EffectHook} hook\n * @param {boolean} isNodeUnmounted\n */\n\n\nfunction destroyEffectHook(hook) {\n  var isNodeUnmounted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (hook.lastDestroy !== undefined && !isNodeUnmounted) {\n    hook.lastDestroy();\n    return;\n  }\n\n  if (hook.destroy !== undefined) {\n    hook.destroy();\n  }\n}\n/**\n *\n * @param {Fiber} fiber\n * @param {boolean} isNewNodeMounted\n */\n\n\nfunction mountEffectsByFiber(fiber, isNewNodeMounted) {\n  fiber.hooks.forEach(function (hook) {\n    if (!(hook instanceof EffectHook)) {\n      return;\n    }\n\n    if (isNewNodeMounted || hook.tag === EFFECT_ALWAYS || hook.tag === EFFECT_DEPS_CHANGED) {\n      mountEffectHook(hook);\n    }\n  });\n}\n/**\n *\n * @param {Fiber} fiber\n * @param {boolean} isNodeUnmounted\n */\n\n\nfunction destroyEffectsByFiber(fiber, isNodeUnmounted) {\n  fiber.hooks.forEach(function (hook) {\n    if (!(hook instanceof EffectHook && (hook.lastDestroy !== undefined || hook.destroy !== undefined))) {\n      return;\n    }\n\n    if (isNodeUnmounted || hook.tag === EFFECT_ALWAYS || hook.tag === EFFECT_DEPS_CHANGED) {\n      destroyEffectHook(hook, isNodeUnmounted);\n    }\n  });\n}\n\nfunction parseTree(rootVirtualNode) {\n  var out = {};\n\n  var walk = function walk(virtualNode) {\n    out[stringifyPath(virtualNode.path)] = virtualNode;\n    virtualNode.children.forEach(function (childVirtualNode) {\n      walk(childVirtualNode);\n    });\n  };\n\n  walk(rootVirtualNode);\n  return out;\n}\n\nfunction resolveUnmountedNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  // const unmountedNodes = [];\n  for (var key in oldVirtualNodeMap) {\n    if (hasOwnProperty(oldVirtualNodeMap, key)) {\n      var unmounted = !hasOwnProperty(newVirtualNodeMap, key);\n      var virtualNode = oldVirtualNodeMap[key];\n      var fiber = virtualNode.fiber;\n\n      if (fiber !== null) {\n        destroyEffectsByFiber(fiber, unmounted);\n\n        if (unmounted) {\n          unlinkFiber(virtualNode.path);\n        }\n      } // if (unmounted) {\n      //     unmountedNodes.push(virtualNode);\n      // }\n\n    }\n  } // console.log('unmounted', unmountedNodes);\n\n}\n\nfunction resolveMountedNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  // const mountedNodes = [];\n  for (var key in newVirtualNodeMap) {\n    if (hasOwnProperty(newVirtualNodeMap, key)) {\n      var mounted = !hasOwnProperty(oldVirtualNodeMap, key);\n      var virtualNode = newVirtualNodeMap[key];\n      var fiber = virtualNode.fiber;\n\n      if (fiber !== null) {\n        mountEffectsByFiber(fiber, mounted);\n      } // if (mounted) {\n      //     mountedNodes.push(virtualNode);\n      // }\n\n    }\n  } // console.log('mounted', mountedNodes);\n\n}\n\nfunction updateComponent(oldRootVirtualNode) {\n  var isInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var walk = function walk(virtualNode) {\n    var parentVirtualNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (virtualNode.type === '#text') {\n      return virtualNode;\n    }\n\n    var fiber = virtualNode.fiber;\n\n    if (fiber === null) {\n      virtualNode.children.forEach(function (childVirtualNode) {\n        walk(childVirtualNode, virtualNode);\n      });\n      return virtualNode;\n    }\n\n    {\n      prepareCurrentlyRendering(fiber);\n      var newVirtualNode = fiber.Component(fiber.props);\n      flushCurrentlyRendering();\n      resolveTree(newVirtualNode, virtualNode.path);\n      fiber.virtualNode = newVirtualNode;\n      newVirtualNode.fiber = fiber;\n      newVirtualNode.parent = parentVirtualNode; // TODO: Research more about this\n      // I don't know why need to check instanceof\n      // If assign to html node, old ref is set, new ref is NOT set\n      // But if assign to fiber node, old ref is NOT set, new ref is set\n\n      if (virtualNode.ref instanceof RefHook) {\n        newVirtualNode.ref = virtualNode.ref;\n      }\n\n      if (parentVirtualNode !== null) {\n        var index = parentVirtualNode.children.indexOf(virtualNode);\n\n        if (index >= 0) {\n          parentVirtualNode.children[index] = newVirtualNode;\n        }\n      }\n\n      newVirtualNode.children.forEach(function (childVirtualNode) {\n        walk(childVirtualNode, newVirtualNode);\n      });\n      return newVirtualNode;\n    }\n  };\n\n  var newRootVirtualNode = walk(oldRootVirtualNode, oldRootVirtualNode.parent);\n  finishResolveTree();\n  var oldVirtualNodeMap = isInit ? {} : parseTree(oldRootVirtualNode);\n  var newVirtualNodeMap = parseTree(newRootVirtualNode);\n  resolveUnmountedNodes(oldVirtualNodeMap, newVirtualNodeMap);\n  hydrateVirtualNodes(newRootVirtualNode);\n  commitToHTML(oldVirtualNodeMap, newVirtualNodeMap);\n  resolveMountedNodes(oldVirtualNodeMap, newVirtualNodeMap);\n  return newRootVirtualNode;\n}\n/**\n * creates an element with certain content and attributes\n *\n * @param {string|function} type\n * @param {{}?} attributes\n * @param {[]} content\n * @return {VirtualNode}\n */\n\n\nfunction createElement(type, attributes) {\n  attributes = attributes || {};\n\n  for (var _len = arguments.length, content = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    content[_key - 2] = arguments[_key];\n  }\n\n  if (type === null) {\n    return createStaticNode.apply(void 0, ['#fragment', attributes].concat(content));\n  }\n\n  if (typeof type === 'function') {\n    return createFiberNode.apply(void 0, [type, attributes].concat(content));\n  }\n\n  return createStaticNode.apply(void 0, [type, attributes].concat(content));\n}\n\nfunction createFiberNode(type, attributes) {\n  var _attributes$key = attributes.key,\n      key = _attributes$key === void 0 ? null : _attributes$key,\n      _attributes$ref = attributes.ref,\n      ref = _attributes$ref === void 0 ? null : _attributes$ref,\n      props = _objectWithoutProperties(attributes, _excluded);\n\n  for (var _len2 = arguments.length, content = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    content[_key2 - 2] = arguments[_key2];\n  }\n\n  props.children = content;\n  var tempPath = generateTemporaryPath();\n  var fiber = new Fiber(type, props);\n  linkFiber(tempPath, fiber);\n  var virtualNode = new VirtualNode(null, props, key, ref);\n\n  virtualNode.resolvePath = function () {\n    unlinkFiber(tempPath);\n    var existedFiber = findFiber(virtualNode.path);\n\n    if (existedFiber) {\n      existedFiber.props = fiber.props;\n      existedFiber.virtualNode = virtualNode;\n      virtualNode.fiber = existedFiber;\n    } else {\n      linkFiber(virtualNode.path, fiber);\n    }\n  }; // Associate virtualNode and fiber\n\n\n  virtualNode.fiber = fiber;\n  fiber.virtualNode = virtualNode;\n  return virtualNode;\n}\n\nfunction createStaticNode(type, attributes) {\n  var _attributes$key2 = attributes.key,\n      key = _attributes$key2 === void 0 ? null : _attributes$key2,\n      _attributes$ref2 = attributes.ref,\n      ref = _attributes$ref2 === void 0 ? null : _attributes$ref2,\n      props = _objectWithoutProperties(attributes, _excluded2);\n\n  var virtualNode = new VirtualNode(type, props, key, ref);\n\n  for (var _len3 = arguments.length, content = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n    content[_key3 - 2] = arguments[_key3];\n  }\n\n  appendVirtualChildren(virtualNode, content);\n  return virtualNode;\n}\n\nfunction appendVirtualChildren(element, content) {\n  var append = function append(item, indexes) {\n    var virtualNode = item;\n\n    if (['string', 'number'].includes(_typeof(item))) {\n      virtualNode = new VirtualNode('#text', {}, null, null);\n      virtualNode.text = item;\n    }\n\n    if (virtualNode instanceof VirtualNode) {\n      element.children.push(virtualNode);\n      normallyEmptyAppendedNodeArray.push(new AppendInfo(element, indexes, virtualNode));\n    }\n  };\n\n  var appendRecursively = function appendRecursively(content, indexes) {\n    if (content instanceof Array) {\n      content.forEach(function (item, idx) {\n        appendRecursively(item, [].concat(_toConsumableArray(indexes), [idx]));\n      });\n    } else {\n      append(content, indexes);\n    }\n  };\n\n  appendRecursively(content, []);\n}\n\nfunction escapeKey(key) {\n  return '@' + encodeURIComponent(key);\n}\n\nfunction resolveTree(rootVirtualNode) {\n  var basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var rootAppendInfo = new AppendInfo(null, [], rootVirtualNode);\n  var arr = normallyEmptyAppendedNodeArray.slice(0);\n\n  var currentPath = _toConsumableArray(basePath);\n  /**\n   *\n   * @param {AppendInfo} appendInfo\n   * @param {VirtualNode} virtualNode\n   */\n\n\n  var walk = function walk(appendInfo, virtualNode) {\n    var pivotPathSize = currentPath.length;\n\n    if (virtualNode !== rootVirtualNode) {\n      currentPath.push.apply(currentPath, _toConsumableArray(appendInfo.routeFromParent)); // If a node has key, replace the index of this node\n      // in the children node list of the parent\n      // by the key\n\n      if (virtualNode.key !== null) {\n        currentPath.pop();\n        currentPath.push(escapeKey(virtualNode.key));\n      } // Add the component type to the current path\n\n\n      if (virtualNode.fiber !== null) {\n        currentPath.push(getComponentType(virtualNode.fiber.Component));\n      } else {\n        currentPath.push(virtualNode.type);\n      }\n    }\n\n    arr = arr.filter(function (item) {\n      if (item.parent === appendInfo.current) {\n        walk(item, item.current);\n        return false;\n      }\n\n      return true;\n    });\n    virtualNode.path = _toConsumableArray(currentPath);\n    virtualNode.parent = appendInfo.parent;\n\n    if (virtualNode.resolvePath !== null) {\n      virtualNode.resolvePath();\n    }\n\n    currentPath.length = pivotPathSize;\n  };\n\n  walk(rootAppendInfo, rootVirtualNode);\n  return rootVirtualNode;\n}\n\nfunction finishResolveTree() {\n  normallyEmptyAppendedNodeArray.length = 0;\n}\n\nfunction hydrateVirtualNodes(virtualNode) {\n  var walk = function walk(virtualNode) {\n    var htmlNode = null;\n\n    if (virtualNode.type === '#fragment') {} else if (virtualNode.type === '#text') {\n      htmlNode = document.createTextNode(virtualNode.text);\n    } else if (typeof virtualNode.type === 'string') {\n      htmlNode = createHTMLElement(virtualNode.type, virtualNode.props);\n    }\n\n    virtualNode.setHtmlNode(htmlNode);\n    virtualNode.children.forEach(function (childVirtualNode) {\n      walk(childVirtualNode);\n    });\n  };\n\n  walk(virtualNode);\n}\n\nfunction commitToHTML(oldVirtualNodeMap, newVirtualNodeMap) {\n  removeOldHtmlNodes(oldVirtualNodeMap, newVirtualNodeMap);\n  updateExistingHtmlNodes(oldVirtualNodeMap, newVirtualNodeMap);\n  appendNewHtmlNodes(oldVirtualNodeMap, newVirtualNodeMap);\n}\n\nfunction removeOldHtmlNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  // If the current node is under the last removed node\n  // So dont need to remove current node anymore\n  // Use lastRemovedKey to track\n  var lastRemovedKey = '';\n\n  for (var key in oldVirtualNodeMap) {\n    if (hasOwnProperty(oldVirtualNodeMap, key) && !hasOwnProperty(newVirtualNodeMap, key)) {\n      if (!key.startsWith(lastRemovedKey + '/')) {\n        var oldVirtualNode = oldVirtualNodeMap[key];\n        removeHtmlNodesByVirtualNode(oldVirtualNode);\n        lastRemovedKey = key;\n      }\n    }\n  }\n}\n\nfunction updateExistingHtmlNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  var keys = Object.keys(_objectSpread(_objectSpread({}, oldVirtualNodeMap), newVirtualNodeMap));\n  keys.forEach(function (key) {\n    if (hasOwnProperty(oldVirtualNodeMap, key) && hasOwnProperty(newVirtualNodeMap, key)) {\n      var oldVirtualNode = oldVirtualNodeMap[key];\n      var newVirtualNode = newVirtualNodeMap[key];\n      newVirtualNode.setHtmlNode(oldVirtualNode.htmlNode);\n      {\n        var htmlNode = newVirtualNode.htmlNode,\n            props = newVirtualNode.props,\n            type = newVirtualNode.type;\n\n        if (type === '#text') {\n          if (newVirtualNode.text !== oldVirtualNode.text) {\n            htmlNode.textContent = newVirtualNode.text;\n          }\n        } else {\n          setAttributes(htmlNode, props);\n        }\n      }\n    }\n  });\n}\n\nfunction appendNewHtmlNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  for (var key in newVirtualNodeMap) {\n    if (hasOwnProperty(newVirtualNodeMap, key) && !hasOwnProperty(oldVirtualNodeMap, key)) {\n      var newVirtualNode = newVirtualNodeMap[key];\n      appendHtmlNodesByVirtualNode(newVirtualNode);\n    }\n  }\n}\n\nfunction appendHtmlNodesByVirtualNode(virtualNode) {\n  var walk = function walk(virtualNode) {\n    var htmlNodes = findClosestHtmlNodes(virtualNode);\n    htmlNodes.forEach(function (htmlNode) {\n      findHtmlHost(virtualNode).appendChild(htmlNode);\n    });\n    virtualNode.children.forEach(function (childVirtualNode) {\n      walk(childVirtualNode);\n    });\n  };\n\n  walk(virtualNode);\n}\n\nfunction removeHtmlNodesByVirtualNode(virtualNode) {\n  var htmlNodes = findClosestHtmlNodes(virtualNode);\n  htmlNodes.forEach(function (htmlNode) {\n    // This should work with out throwing error\n    // But to be safe\n    // And we can see the error log if something went wrong\n    // while keeping the UI to be not crashed\n    try {\n      findHtmlHost(virtualNode).removeChild(htmlNode);\n    } catch (e) {\n      console.error('Unable to remove:', htmlNode, 'from:', htmlNode.parentNode);\n    }\n  });\n}\n\nfunction findHtmlHost(virtualNode) {\n  if (!virtualNode.parent) {\n    return null;\n  }\n\n  if (virtualNode.parent.htmlNode) {\n    return virtualNode.parent.htmlNode;\n  }\n\n  return findHtmlHost(virtualNode.parent);\n}\n\nfunction findClosestHtmlNodes(virtualNode) {\n  if (virtualNode.htmlNode !== null) {\n    return [virtualNode.htmlNode];\n  } else {\n    return virtualNode.children.reduce(function (arr, childVirtualNode) {\n      return arr.concat(findClosestHtmlNodes(childVirtualNode));\n    }, []);\n  }\n}\n\nfunction render(rootVirtualNode, container) {\n  resolveTree(rootVirtualNode, [getContainerId(container)]);\n  finishResolveTree();\n  var containerVirtualNode = new VirtualNode(container.nodeName.toLowerCase(), {}, null, null);\n  containerVirtualNode.setHtmlNode(container);\n  rootVirtualNode.parent = containerVirtualNode;\n  var newRootVirtualNode = updateComponent(rootVirtualNode, true); // console.log('RootVirtualNode', newRootVirtualNode);\n} //============================\n\n\nvar SVG_TAGS = ['svg', 'g', 'circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'];\n\nfunction createHTMLElement(type, attributes) {\n  var node = SVG_TAGS.includes(type) ? document.createElementNS(\"http://www.w3.org/2000/svg\", type) : document.createElement(type);\n  setAttributes(node, attributes);\n  return node;\n}\n/**\n * sets attributes for a node\n *\n * @param {HTMLElement} element\n * @param {object} attributes\n */\n\n\nfunction setAttributes(element, attributes) {\n  for (var attrName in attributes) {\n    if (hasOwnProperty(attributes, attrName)) {\n      setAttribute(element, attrName, attributes[attrName]);\n    }\n  }\n}\n\nfunction setAttribute(element, attrName, attrValue) {\n  var _transformAttribute = transformAttribute(attrName, attrValue),\n      _transformAttribute2 = _slicedToArray(_transformAttribute, 2),\n      name = _transformAttribute2[0],\n      value = _transformAttribute2[1];\n\n  if (name === 'style') {\n    // TODO: Compare with old style to update exactly what changed\n    for (var prop in value) {\n      if (hasOwnProperty(value, prop)) {\n        if (value[prop] !== undefined) {\n          element.style[prop] = value[prop];\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (['function', 'boolean'].includes(_typeof(value))) {\n    element[name] = value;\n    return;\n  }\n\n  if (value !== undefined) {\n    element.setAttribute(name, value);\n  }\n}\n\nfunction transformAttribute(name, value) {\n  var valueType = _typeof(value);\n\n  if (valueType === 'function') {\n    return [name.toLowerCase(), value];\n  }\n\n  if (name === 'class' || name === 'className') {\n    if (valueType === 'string') {\n      return ['class', value];\n    } else {\n      // Array of class names\n      return ['class', value.filter(function (t) {\n        return typeof t === 'string';\n      }).join(' ')];\n    }\n  }\n\n  return [name, value];\n} // ========================\n\n\nfunction hasOwnProperty(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName);\n} // ========================\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  $: createElement,\n  render: render,\n  useState: useState,\n  useEffect: useEffect,\n  useRef: useRef\n});\n\n//# sourceURL=webpack://sandbox/../lib.js?");

/***/ }),

/***/ "./src/mount.js":
/*!**********************!*\
  !*** ./src/mount.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ \"../index.js\");\n\n\nfunction DemoWrapperWrapper() {\n  return _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].$(null, null, \"Mount\");\n}\n\n_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].render(_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].$(DemoWrapperWrapper, null), document.getElementById('sandbox-container'));\n\n//# sourceURL=webpack://sandbox/./src/mount.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/mount.js");
/******/ 	
/******/ })()
;