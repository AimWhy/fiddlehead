/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../output/dist/index.js":
/*!*******************************!*\
  !*** ../output/dist/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nvar _excluded = [\"key\", \"ref\"],\n    _excluded2 = [\"key\", \"ref\"];\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nfunction hasOwnProperty(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName);\n}\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number' || value instanceof Number;\n}\n\nfunction isFunction(value) {\n  return value instanceof Function;\n}\n\nfunction isArray(value) {\n  return value instanceof Array;\n}\n\nfunction isPlainObject(value) {\n  return !!value && value.constructor === Object;\n}\n\nfunction isEmpty(value) {\n  return value === undefined || value === null;\n}\n\nvar currentlyProcessingFunctionalVirtualNode = null;\nvar currentlyProcessingHookIndex = -1;\n\nfunction prepareCurrentlyProcessing(functionalVirtualNode) {\n  currentlyProcessingFunctionalVirtualNode = functionalVirtualNode;\n  currentlyProcessingHookIndex = -1;\n}\n\nfunction flushCurrentlyProcessing() {\n  currentlyProcessingFunctionalVirtualNode = null;\n  currentlyProcessingHookIndex = -1;\n}\n\nfunction resolveCurrentlyProcessing() {\n  if (currentlyProcessingFunctionalVirtualNode === null) {\n    throw new Error('Cannot call hooks from outside of the component');\n  }\n\n  return [currentlyProcessingFunctionalVirtualNode, ++currentlyProcessingHookIndex];\n}\n/**\n *\n * @param {*} current\n * @constructor\n */\n\n\nfunction RefHook(current) {\n  this.current = current;\n}\n\nfunction useRef(initialValue) {\n  var _resolveCurrentlyProc = resolveCurrentlyProcessing(),\n      _resolveCurrentlyProc2 = _slicedToArray(_resolveCurrentlyProc, 2),\n      functionalVirtualNode = _resolveCurrentlyProc2[0],\n      hookIndex = _resolveCurrentlyProc2[1];\n\n  if (functionalVirtualNode.hooks_.length > hookIndex) {\n    return functionalVirtualNode.hooks_[hookIndex];\n  }\n\n  var hook = new RefHook(initialValue);\n  functionalVirtualNode.hooks_.push(hook);\n  return hook;\n}\n/**\n *\n * @param {string|function} type\n * @param {{}} props\n * @param {string|null} key\n * @param {RefHook|null} ref\n * @return {VirtualNode}\n * @constructor\n */\n\n\nfunction VirtualNode(type, props, key, ref) {\n  this.type_ = type;\n  this.props_ = props;\n  this.key_ = key;\n  this.ref_ = ref;\n  this.hooks_ = [];\n  this.parent_ = null;\n  this.children_ = [];\n  this.path_ = [];\n  this.posInRow_ = null;\n  this.data_ = null;\n  this.nativeNode_ = null;\n  this.ns_ = null;\n} // Use special URI characters\n\n\nvar NODE_TEXT = '#';\nvar NODE_ARRAY = '[';\nvar NODE_FRAGMENT = '<';\nvar NS_HTML = 'html';\nvar NS_SVG = 'svg';\n\nfunction linkNativeNode(virtualNode, nativeNode) {\n  virtualNode.nativeNode_ = nativeNode;\n\n  if (virtualNode.ref_ instanceof RefHook) {\n    virtualNode.ref_.current = nativeNode;\n  }\n}\n/**\n *\n * @param {*} content\n * @return {null|VirtualNode}\n */\n\n\nfunction createVirtualNodeFromContent(content) {\n  if (content instanceof VirtualNode) {\n    return content;\n  }\n\n  if (isString(content) || isNumber(content)) {\n    var node = new VirtualNode(NODE_TEXT, {}, null, null);\n    node.data_ = content;\n    return node;\n  }\n\n  if (isArray(content)) {\n    var _node = new VirtualNode(NODE_ARRAY, {}, null, null);\n\n    var posInRow = -1;\n\n    for (var i = 0; i < content.length; i++) {\n      var child = createVirtualNodeFromContent(content[i]);\n\n      if (child !== null) {\n        appendChildVirtualNode(_node, child, ++posInRow);\n      }\n    }\n\n    return _node;\n  }\n\n  return null;\n}\n/**\n * \n * @param {VirtualNode} parent \n * @param {VirtualNode} child\n * @param {number} posInRow\n */\n\n\nfunction appendChildVirtualNode(parent, child, posInRow) {\n  child.parent_ = parent;\n  child.posInRow_ = posInRow;\n  parent.children_[posInRow] = child;\n}\n/**\n *\n * @param {string|function} type\n * @param {{}?} attributes\n * @param {[]} content\n * @return {VirtualNode}\n */\n\n\nfunction createElement(type, attributes) {\n  attributes = attributes || {};\n\n  for (var _len = arguments.length, content = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    content[_key - 2] = arguments[_key];\n  }\n\n  if (type === null) {\n    return _createStaticVirtualNode.apply(void 0, [NODE_FRAGMENT, attributes].concat(content));\n  }\n\n  if (isFunction(type)) {\n    return _createFunctionalVirtualNode.apply(void 0, [type, attributes].concat(content));\n  }\n\n  return _createStaticVirtualNode.apply(void 0, [type, attributes].concat(content));\n}\n\nfunction _createFunctionalVirtualNode(type, attributes) {\n  var _attributes$key = attributes.key,\n      key = _attributes$key === void 0 ? null : _attributes$key,\n      _attributes$ref = attributes.ref,\n      ref = _attributes$ref === void 0 ? null : _attributes$ref,\n      props = _objectWithoutProperties(attributes, _excluded); // JSX children\n\n\n  for (var _len2 = arguments.length, content = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    content[_key2 - 2] = arguments[_key2];\n  }\n\n  props.children = content;\n  return new VirtualNode(type, props, key, ref);\n}\n\nfunction _createStaticVirtualNode(type, attributes) {\n  var _attributes$key2 = attributes.key,\n      key = _attributes$key2 === void 0 ? null : _attributes$key2,\n      _attributes$ref2 = attributes.ref,\n      ref = _attributes$ref2 === void 0 ? null : _attributes$ref2,\n      props = _objectWithoutProperties(attributes, _excluded2);\n\n  var newNode = new VirtualNode(type, props, key, ref);\n  var posInRow = -1;\n\n  for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {\n    var childNode = createVirtualNodeFromContent(i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);\n\n    if (childNode !== null) {\n      appendChildVirtualNode(newNode, childNode, ++posInRow);\n    }\n  }\n\n  return newNode;\n}\n/**\n * \n * @param {Array<string|number} path \n * @returns {string}\n */\n\n\nfunction pathToString(path) {\n  return path.join('/');\n} // Note:\n// Use special URI characters as prefixes\n\n/**\n * \n * @param {*} key \n * @returns {string}\n */\n\n\nfunction escapeVirtualNodeKey(key) {\n  return '@' + encodeURIComponent(key);\n}\n\nvar functionalTypeInc = 0;\n/**\n * \n * @param {Function} type \n * @returns {string}\n */\n\nfunction createFunctionalTypeAlias(type) {\n  return (\n    /*type.name +*/\n    '{' + (++functionalTypeInc).toString(36)\n  );\n}\n\nvar containerIdInc = 0;\n/**\n * \n * @returns {string}\n */\n\nfunction createContainerId() {\n  return '~' + (++containerIdInc).toString(36);\n}\n\nvar PROP_TYPE_ALIAS = 'hook_alias';\nvar PROP_CONTAINER_ID = 'hook_cid';\nvar PROP_VIRTUAL_NODE = 'hook_vnode';\n/**\n * \n * @param {Element} container \n * @returns {string}\n */\n\nfunction getContainerId(container) {\n  if (!hasOwnProperty(container, PROP_CONTAINER_ID)) {\n    container[PROP_CONTAINER_ID] = createContainerId();\n  }\n\n  return container[PROP_CONTAINER_ID];\n}\n/**\n *\n * @param {Function} type\n * @returns {string}\n */\n\n\nfunction getFunctionalTypeAlias(type) {\n  if (!hasOwnProperty(type, PROP_TYPE_ALIAS)) {\n    type[PROP_TYPE_ALIAS] = createFunctionalTypeAlias();\n  }\n\n  return type[PROP_TYPE_ALIAS];\n}\n/**\n * \n * @param {Node} nativeNode \n * @param {VirtualNode} virtualNode \n */\n\n\nfunction attachVirtualNode(nativeNode, virtualNode) {\n  nativeNode[PROP_VIRTUAL_NODE] = virtualNode;\n}\n/**\n *\n * @type {Object<VirtualNode>}\n */\n\n\nvar memoizedHooksMap = Object.create(null);\n\nfunction findMemoizedHooks(path) {\n  var pathString = pathToString(path);\n\n  if (hasOwnProperty(memoizedHooksMap, pathString)) {\n    return memoizedHooksMap[pathString];\n  }\n\n  return null;\n}\n\nfunction linkMemoizedHooks(path, functionalVirtualNode) {\n  memoizedHooksMap[pathToString(path)] = functionalVirtualNode;\n}\n\nfunction unlinkMemoizedHooks(path) {\n  delete memoizedHooksMap[pathToString(path)];\n}\n\nfunction createNativeTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction updateNativeTextNode(node, text) {\n  node.textContent = text;\n}\n\nfunction createNativeElementWithNS(ns, type, attributes) {\n  var node = ns !== null ? document.createElementNS(ns, type) : document.createElement(type);\n  updateNativeElementAttributes(node, attributes, {});\n  return node;\n}\n\nfunction updateNativeElementAttributes(element, newAttributes, oldAttributes) {\n  for (var attrName in oldAttributes) {\n    if (hasOwnProperty(oldAttributes, attrName)) {\n      if (isEmpty(newAttributes[attrName])) {\n        _removeNativeElementAttribute(element, attrName, oldAttributes[attrName]);\n      }\n    }\n  }\n\n  for (var _attrName in newAttributes) {\n    if (hasOwnProperty(newAttributes, _attrName)) {\n      _setNativeElementAttribute(element, _attrName, newAttributes[_attrName], oldAttributes[_attrName]);\n    }\n  }\n}\n\nfunction _removeNativeElementAttribute(element, attrName, attrValue) {\n  var _transformNativeEleme = _transformNativeElementAttribute(attrName, attrValue),\n      _transformNativeEleme2 = _slicedToArray(_transformNativeEleme, 2),\n      name = _transformNativeEleme2[0],\n      value = _transformNativeEleme2[1];\n\n  if (isEmpty(value)) {\n    return;\n  }\n\n  element.removeAttribute(name);\n}\n\nfunction _setNativeElementAttribute(element, attrName, attrValue, oldAttrValue) {\n  var _transformNativeEleme3 = _transformNativeElementAttribute(attrName, attrValue),\n      _transformNativeEleme4 = _slicedToArray(_transformNativeEleme3, 2),\n      name = _transformNativeEleme4[0],\n      value = _transformNativeEleme4[1];\n\n  if (isEmpty(value)) {\n    return;\n  }\n\n  if (name === 'style') {\n    if (!isEmpty(oldAttrValue)) {\n      var _transformNativeEleme5 = _transformNativeElementAttribute(attrName, oldAttrValue),\n          _transformNativeEleme6 = _slicedToArray(_transformNativeEleme5, 2),\n          oldValue = _transformNativeEleme6[1];\n\n      if (!isEmpty(oldValue)) {\n        for (var prop in oldValue) {\n          if (hasOwnProperty(oldValue, prop) && !hasOwnProperty(value, prop)) {\n            // Delete this style property\n            element.style[prop] = '';\n          }\n        }\n      }\n    }\n\n    for (var _prop in value) {\n      if (hasOwnProperty(value, _prop)) {\n        if (!isEmpty(value[_prop])) {\n          element.style[_prop] = value[_prop];\n        }\n      }\n    }\n\n    return;\n  }\n\n  if (isString(value) || isNumber(value)) {\n    element.setAttribute(name, value);\n  } // For properties, event listeners\n\n\n  if (name in element) {\n    try {\n      element[name] = value;\n    } catch (e) {// The property is not writable\n    }\n  }\n}\n\nfunction _transformNativeElementAttribute(name, value) {\n  if (isFunction(value)) {\n    return [name.toLowerCase(), value];\n  }\n\n  if (name === 'className') {\n    if (isArray(value)) {\n      return ['class', value.filter(function (t) {\n        return isString(t);\n      }).join(' ')];\n    } else {\n      return ['class', value];\n    }\n  }\n\n  if (name === 'class') {\n    console.error('className instead of class');\n    return [name];\n  }\n\n  if (name === 'style') {\n    if (!isEmpty(value) && !isPlainObject(value)) {\n      console.error('Style must be a plain object', value);\n      return [name];\n    }\n  }\n\n  return [name, value];\n}\n\nfunction hydrateVirtualTree(virtualNode) {\n  // Determine the namespace\n  if (virtualNode.type_ === 'svg') {\n    virtualNode.ns_ = NS_SVG;\n  } else {\n    if (virtualNode.parent_ !== null) {\n      virtualNode.ns_ = virtualNode.parent_.ns_;\n    } else {\n      virtualNode.ns_ = NS_HTML;\n    }\n  } // Create the native node\n\n\n  var nativeNode = null;\n\n  if (virtualNode.type_ === NODE_TEXT) {\n    nativeNode = createNativeTextNode(virtualNode.data_);\n  } else if (virtualNode.type_ === NODE_FRAGMENT || virtualNode.type_ === NODE_ARRAY) ;else if (isString(virtualNode.type_)) {\n    var nativeNS = null;\n\n    if (virtualNode.ns_ === NS_SVG) {\n      nativeNS = 'http://www.w3.org/2000/svg';\n    }\n\n    nativeNode = createNativeElementWithNS(nativeNS, virtualNode.type_, virtualNode.props_); // For debug\n\n    attachVirtualNode(nativeNode, virtualNode);\n  }\n\n  linkNativeNode(virtualNode, nativeNode); // Continue with the children\n\n  for (var i = 0; i < virtualNode.children_.length; i++) {\n    hydrateVirtualTree(virtualNode.children_[i]);\n  }\n}\n\nfunction commitView(oldVirtualNodeMap, newVirtualNodeMap) {\n  _removeOldNativeNodes(oldVirtualNodeMap, newVirtualNodeMap);\n\n  _updateExistingNativeNodes(oldVirtualNodeMap, newVirtualNodeMap);\n\n  _insertNewNativeNodes(oldVirtualNodeMap, newVirtualNodeMap);\n}\n\nfunction _removeOldNativeNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  // If the current node is under the last removed node\n  // So dont need to remove current node anymore\n  // Use lastRemovedKey to track\n  var lastRemovedKey = '';\n\n  for (var key in oldVirtualNodeMap) {\n    if (hasOwnProperty(oldVirtualNodeMap, key) && !hasOwnProperty(newVirtualNodeMap, key)) {\n      if (!key.startsWith(lastRemovedKey + '/')) {\n        var oldVirtualNode = oldVirtualNodeMap[key];\n\n        if (oldVirtualNode.nativeNode_ !== null) {\n          _removeNativeNodesOfVirtualNode(oldVirtualNode);\n\n          lastRemovedKey = key;\n        }\n      }\n    }\n  }\n}\n\nfunction _updateExistingNativeNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  var mergedKeys = Object.keys(_objectSpread(_objectSpread({}, oldVirtualNodeMap), newVirtualNodeMap));\n\n  for (var i = 0; i < mergedKeys.length; i++) {\n    var key = mergedKeys[i];\n\n    if (hasOwnProperty(oldVirtualNodeMap, key) && hasOwnProperty(newVirtualNodeMap, key)) {\n      var newVirtualNode = newVirtualNodeMap[key];\n\n      if (newVirtualNode.nativeNode_ !== null) {\n        var oldVirtualNode = oldVirtualNodeMap[key]; // Reuse the existing native node\n\n        linkNativeNode(newVirtualNode, oldVirtualNode.nativeNode_);\n\n        if (newVirtualNode.type_ === NODE_TEXT) {\n          if (newVirtualNode.data_ !== oldVirtualNode.data_) {\n            updateNativeTextNode(newVirtualNode.nativeNode_, newVirtualNode.data_);\n          }\n        } else {\n          updateNativeElementAttributes(newVirtualNode.nativeNode_, newVirtualNode.props_, oldVirtualNode.props_);\n        }\n      }\n    }\n  }\n}\n\nfunction _insertNewNativeNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  var pendingVirtualNodes = [];\n\n  for (var key in newVirtualNodeMap) {\n    if (hasOwnProperty(newVirtualNodeMap, key)) {\n      if (!hasOwnProperty(oldVirtualNodeMap, key)) {\n        var newVirtualNode = newVirtualNodeMap[key];\n\n        if (newVirtualNode.nativeNode_ !== null) {\n          pendingVirtualNodes.push(newVirtualNode);\n        }\n      } else {\n        _insertClosestNativeNodesOfVirtualNodes(pendingVirtualNodes, oldVirtualNodeMap[key]);\n\n        pendingVirtualNodes.length = 0;\n      }\n    }\n  }\n\n  if (pendingVirtualNodes.length > 0) {\n    _insertClosestNativeNodesOfVirtualNodes(pendingVirtualNodes, null);\n  }\n}\n\nfunction _insertClosestNativeNodesOfVirtualNodes(virtualNodes, virtualNodeAfter) {\n  var nativeNodeAfter = virtualNodeAfter && _findClosestNativeNodes(virtualNodeAfter)[0] || null;\n\n  for (var i = 0; i < virtualNodes.length; i++) {\n    var virtualNode = virtualNodes[i];\n\n    if (virtualNode.nativeNode_ !== null) {\n      var nativeHost = _findNativeHost(virtualNode);\n\n      if (nativeHost !== null) {\n        if (nativeNodeAfter !== null && nativeHost === nativeNodeAfter.parentNode) {\n          nativeHost.insertBefore(virtualNode.nativeNode_, nativeNodeAfter);\n        } else {\n          nativeHost.appendChild(virtualNode.nativeNode_);\n        }\n      }\n    }\n  }\n}\n\nfunction _removeNativeNodesOfVirtualNode(virtualNode) {\n  var nativeNodes = _findClosestNativeNodes(virtualNode);\n\n  for (var i = 0; i < nativeNodes.length; i++) {\n    var nativeNode = nativeNodes[i];\n\n    if (nativeNode.parentNode !== null) {\n      nativeNode.parentNode.removeChild(nativeNode);\n    }\n  }\n}\n\nfunction _findNativeHost(virtualNode) {\n  if (virtualNode.parent_ === null) {\n    return null;\n  }\n\n  if (virtualNode.parent_.nativeNode_ === null) {\n    return _findNativeHost(virtualNode.parent_);\n  }\n\n  return virtualNode.parent_.nativeNode_;\n}\n\nfunction _findClosestNativeNodes(virtualNode) {\n  if (virtualNode.nativeNode_ !== null) {\n    return [virtualNode.nativeNode_];\n  } else {\n    return virtualNode.children_.reduce(function (arr, childVirtualNode) {\n      return arr.concat(_findClosestNativeNodes(childVirtualNode));\n    }, []);\n  }\n}\n/**\n *\n * @param {function} callback\n * @param {[]|null} deps\n * @param {function} lastDestroy\n * @return {EffectHook}\n * @constructor\n */\n\n\nfunction EffectHook(callback, deps, lastDestroy) {\n  this.tag_ = EFFECT_NONE;\n  this.callback_ = callback;\n  this.deps_ = deps;\n  this.destroy_ = null;\n  this.lastDestroy_ = lastDestroy;\n}\n\nvar EFFECT_NONE = 0;\nvar EFFECT_ALWAYS = 1;\nvar EFFECT_LAZY = 2;\nvar EFFECT_DEPS = 3;\nvar EFFECT_DEPS_CHANGED = 4;\n\nfunction useEffect(callback) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  var _resolveCurrentlyProc3 = resolveCurrentlyProcessing(),\n      _resolveCurrentlyProc4 = _slicedToArray(_resolveCurrentlyProc3, 2),\n      functionalVirtualNode = _resolveCurrentlyProc4[0],\n      hookIndex = _resolveCurrentlyProc4[1];\n\n  if (functionalVirtualNode.hooks_.length > hookIndex) {\n    /**\n     * @type {EffectHook}\n     */\n    var currentHook = functionalVirtualNode.hooks_[hookIndex];\n\n    if (!(deps === null && currentHook.deps_ === null || deps.length === currentHook.deps_.length)) {\n      throw new Error('Deps must be size-fixed');\n    }\n\n    var effectTag = _getEffectTag(deps, currentHook.deps_);\n\n    if (effectTag === EFFECT_LAZY) {\n      return;\n    }\n\n    if (effectTag === EFFECT_DEPS) {\n      currentHook.tag_ = effectTag;\n      return;\n    }\n\n    if (effectTag === EFFECT_ALWAYS || effectTag === EFFECT_DEPS_CHANGED) {\n      var newHook = new EffectHook(callback, deps, currentHook.destroy_);\n      newHook.tag_ = effectTag;\n      functionalVirtualNode.hooks_[hookIndex] = newHook;\n      return;\n    }\n\n    return;\n  }\n\n  var hook = new EffectHook(callback, deps, null);\n  hook.tag_ = _getEffectTag(deps);\n  functionalVirtualNode.hooks_.push(hook);\n}\n/**\n *\n * @param {VirtualNode} functionalVirtualNode\n * @param {boolean} isNewNodeMounted\n */\n\n\nfunction mountEffectsOnFunctionalVirtualNode(functionalVirtualNode, isNewNodeMounted) {\n  for (var i = 0; i < functionalVirtualNode.hooks_.length; i++) {\n    var hook = functionalVirtualNode.hooks_[i];\n\n    if (!(hook instanceof EffectHook)) {\n      continue;\n    }\n\n    if (isNewNodeMounted || hook.tag_ === EFFECT_ALWAYS || hook.tag_ === EFFECT_DEPS_CHANGED) {\n      _mountEffectHook(hook);\n    }\n  }\n}\n/**\n *\n * @param {VirtualNode} functionalVirtualNode\n * @param {boolean} isNodeUnmounted\n */\n\n\nfunction destroyEffectsOnFunctionalVirtualNode(functionalVirtualNode, isNodeUnmounted) {\n  for (var i = 0; i < functionalVirtualNode.hooks_.length; i++) {\n    var hook = functionalVirtualNode.hooks_[i];\n\n    if (!(hook instanceof EffectHook && (hook.lastDestroy_ !== null || hook.destroy_ !== null))) {\n      continue;\n    }\n\n    if (isNodeUnmounted || hook.tag_ === EFFECT_ALWAYS || hook.tag_ === EFFECT_DEPS_CHANGED) {\n      _destroyEffectHook(hook, isNodeUnmounted);\n    }\n  }\n}\n/**\n *\n * @param {EffectHook} effectHook\n */\n\n\nfunction _mountEffectHook(effectHook) {\n  effectHook.destroy_ = effectHook.callback_();\n}\n/**\n *\n * @param {EffectHook} hook\n * @param {boolean} isNodeUnmounted\n */\n\n\nfunction _destroyEffectHook(hook) {\n  var isNodeUnmounted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (hook.lastDestroy_ !== null && !isNodeUnmounted) {\n    hook.lastDestroy_();\n    return;\n  }\n\n  if (hook.destroy_ !== null) {\n    hook.destroy_();\n  }\n}\n\nfunction _getEffectTag(deps) {\n  var lastDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // Always\n  if (deps === null) {\n    return EFFECT_ALWAYS;\n  } // Lazy\n\n\n  if (deps.length === 0) {\n    return EFFECT_LAZY;\n  } // Deps\n\n\n  if (lastDeps === false || _compareSameLengthArrays(deps, lastDeps)) {\n    return EFFECT_DEPS;\n  } // DepsChanged\n\n\n  {\n    return EFFECT_DEPS_CHANGED;\n  }\n}\n\nfunction _compareSameLengthArrays(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n *\n * @param {VirtualNode} rootVirtualNode\n * @param {boolean} initial\n */\n\n\nfunction updateVirtualTree(rootVirtualNode, initial) {\n  var oldVirtualNodeMap = initial ? {} : _getVirtualNodeMap(rootVirtualNode);\n\n  _updateVirtualNodeRecursive(rootVirtualNode);\n\n  var newVirtualNodeMap = _getVirtualNodeMap(rootVirtualNode);\n\n  _resolveUnmountedVirtualNodes(oldVirtualNodeMap, newVirtualNodeMap);\n\n  hydrateVirtualTree(rootVirtualNode);\n  commitView(oldVirtualNodeMap, newVirtualNodeMap);\n\n  _resolveMountedVirtualNodes(oldVirtualNodeMap, newVirtualNodeMap);\n}\n/**\n *\n * @param {VirtualNode} virtualNode\n */\n\n\nfunction _updateVirtualNodeRecursive(virtualNode) {\n  if (virtualNode.type_ === NODE_TEXT) {\n    return;\n  }\n\n  if (!isFunction(virtualNode.type_)) {\n    for (var i = 0; i < virtualNode.children_.length; i++) {\n      _updateVirtualNodeRecursive(virtualNode.children_[i]);\n    }\n\n    return;\n  }\n\n  prepareCurrentlyProcessing(virtualNode);\n  var newVirtualNode = createVirtualNodeFromContent(virtualNode.type_(virtualNode.props_));\n  flushCurrentlyProcessing();\n\n  if (newVirtualNode !== null) {\n    appendChildVirtualNode(virtualNode, newVirtualNode, 0); // This step aimed to read memoized hooks and restore them\n\n    resolveVirtualTree(virtualNode); // Recursion\n\n    _updateVirtualNodeRecursive(newVirtualNode);\n  }\n}\n\nfunction _resolveUnmountedVirtualNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  for (var key in oldVirtualNodeMap) {\n    if (hasOwnProperty(oldVirtualNodeMap, key)) {\n      var unmounted = !hasOwnProperty(newVirtualNodeMap, key);\n      var virtualNode = oldVirtualNodeMap[key];\n\n      if (isFunction(virtualNode.type_)) {\n        destroyEffectsOnFunctionalVirtualNode(virtualNode, unmounted);\n\n        if (unmounted) {\n          unlinkMemoizedHooks(virtualNode.path_);\n        }\n      }\n    }\n  }\n}\n\nfunction _resolveMountedVirtualNodes(oldVirtualNodeMap, newVirtualNodeMap) {\n  for (var key in newVirtualNodeMap) {\n    if (hasOwnProperty(newVirtualNodeMap, key)) {\n      var mounted = !hasOwnProperty(oldVirtualNodeMap, key);\n      var virtualNode = newVirtualNodeMap[key];\n\n      if (isFunction(virtualNode.type_)) {\n        mountEffectsOnFunctionalVirtualNode(virtualNode, mounted);\n      }\n    }\n  }\n}\n\nfunction _getVirtualNodeMap(rootVirtualNode) {\n  var outputMap = Object.create(null);\n\n  _walkVirtualNode(rootVirtualNode, outputMap);\n\n  return outputMap;\n}\n\nfunction _walkVirtualNode(virtualNode, outputMap) {\n  outputMap[pathToString(virtualNode.path_)] = virtualNode;\n\n  for (var i = 0; i < virtualNode.children_.length; i++) {\n    _walkVirtualNode(virtualNode.children_[i], outputMap);\n  }\n}\n/**\n *\n * @param {VirtualNode} context\n * @param {*} initialValue\n * @constructor\n */\n\n\nfunction StateHook(context, initialValue) {\n  var _this = this;\n\n  this.context_ = context;\n  this.value_ = initialValue;\n\n  this.setValue_ = function (value) {\n    var newValue;\n\n    if (isFunction(value)) {\n      newValue = value(_this.value_);\n    } else {\n      newValue = value;\n    }\n\n    if (newValue !== _this.value_) {\n      _this.value_ = newValue;\n      updateVirtualTree(_this.context_, false);\n    }\n  };\n}\n\nfunction useState(initialValue) {\n  var _resolveCurrentlyProc5 = resolveCurrentlyProcessing(),\n      _resolveCurrentlyProc6 = _slicedToArray(_resolveCurrentlyProc5, 2),\n      functionalVirtualNode = _resolveCurrentlyProc6[0],\n      hookIndex = _resolveCurrentlyProc6[1];\n\n  if (functionalVirtualNode.hooks_.length > hookIndex) {\n    var _hook = functionalVirtualNode.hooks_[hookIndex];\n    return [_hook.value_, _hook.setValue_];\n  }\n\n  var hook = new StateHook(functionalVirtualNode, initialValue);\n  functionalVirtualNode.hooks_.push(hook);\n  return [hook.value_, hook.setValue_];\n}\n\nfunction resolveVirtualTree(rootVirtualNode) {\n  for (var i = 0; i < rootVirtualNode.children_.length; i++) {\n    _resolveVirtualNodeRecursive(rootVirtualNode.children_[i], rootVirtualNode.path_);\n  }\n}\n\nfunction _resolveVirtualNodeRecursive(virtualNode, parentPath) {\n  // Don't change the passed path\n  var currentPath = _toConsumableArray(parentPath); // If a node has key, replace the index of this node\n  // in the children node list of the parent\n  // by the key\n\n\n  if (virtualNode.key_ !== null) {\n    currentPath.push(escapeVirtualNodeKey(virtualNode.key_));\n  } else {\n    currentPath.push(virtualNode.posInRow_);\n  } // Add the component type to the current path\n\n\n  if (isFunction(virtualNode.type_)) {\n    currentPath.push(getFunctionalTypeAlias(virtualNode.type_));\n  } else {\n    currentPath.push(virtualNode.type_);\n  } // Set path\n\n\n  virtualNode.path_ = currentPath; // Restore memoized states\n\n  if (isFunction(virtualNode.type_)) {\n    var memoizedHooks = findMemoizedHooks(virtualNode.path_);\n\n    if (memoizedHooks !== null) {\n      // Here, new node does not have any hooks\n      // because it is in the pending state\n      // After when the tree is established\n      // and then updating, the hooks will be called (or created if it is the first time)\n      virtualNode.hooks_ = memoizedHooks;\n\n      for (var i = 0; i < virtualNode.hooks_.length; i++) {\n        var hook = virtualNode.hooks_[i];\n\n        if (hook instanceof StateHook) {\n          hook.context_ = virtualNode;\n        }\n      }\n    }\n\n    linkMemoizedHooks(virtualNode.path_, virtualNode.hooks_);\n  } // Recursion\n\n\n  for (var _i2 = 0; _i2 < virtualNode.children_.length; _i2++) {\n    _resolveVirtualNodeRecursive(virtualNode.children_[_i2], currentPath);\n  }\n}\n/**\n *\n * @param {*} root\n * @param {Element} container\n */\n\n\nfunction mount(root, container) {\n  if (container.firstChild) {\n    throw new Error('Container must be empty');\n  }\n\n  var rootVirtualNode = createVirtualNodeFromContent(root);\n  var containerVirtualNode = new VirtualNode(container.nodeName.toLowerCase(), {}, null, null);\n  containerVirtualNode.path_ = [getContainerId(container)];\n  containerVirtualNode.ns_ = container.ownerSVGElement ? NS_SVG : NS_HTML;\n  linkNativeNode(containerVirtualNode, container);\n  attachVirtualNode(container, containerVirtualNode);\n  appendChildVirtualNode(containerVirtualNode, rootVirtualNode, 0);\n  resolveVirtualTree(containerVirtualNode);\n  updateVirtualTree(rootVirtualNode, true);\n}\n\nexports.h = createElement;\nexports.mount = mount;\nexports.useEffect = useEffect;\nexports.useRef = useRef;\nexports.useState = useState;\n\n//# sourceURL=webpack://sandbox/../output/dist/index.js?");

/***/ }),

/***/ "./src/mount.js":
/*!**********************!*\
  !*** ./src/mount.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../output/dist/index.js */ \"../output/dist/index.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\nfunction Wrapper2(_ref) {\n  var children = _ref.children,\n      myRef = _ref.myRef;\n  return (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", {\n    className: \"Wrapper\",\n    ref: myRef\n  }, children);\n}\n\nfunction Wrapper(_ref2) {\n  var children = _ref2.children,\n      myRef = _ref2.myRef;\n  return (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(Wrapper2, {\n    myRef: myRef\n  }, children);\n}\n\nfunction DemoWrapperWrapper() {\n  var _useState = (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.useState)('A'),\n      _useState2 = _slicedToArray(_useState, 2),\n      layout = _useState2[0],\n      setLayout = _useState2[1];\n\n  var rootRef = (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var wrapperRef = (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    console.log('effect always', rootRef.current, wrapperRef.current);\n    return function () {\n      console.log('unmount always', rootRef.current, wrapperRef.current);\n    };\n  });\n  (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    console.log('effect deps', rootRef.current, wrapperRef.current);\n    return function () {\n      console.log('unmount deps', rootRef.current, wrapperRef.current);\n    };\n  }, [layout]);\n  (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n    console.log('effect lazy', rootRef.current, wrapperRef.current);\n    return function () {\n      console.log('unmount lazy', rootRef.current, wrapperRef.current);\n    };\n  }, []);\n  return (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    className: \"Root\",\n    ref: rootRef\n  }, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"select\", {\n    onChange: function onChange(ev) {\n      return setLayout(ev.target.value);\n    }\n  }, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"option\", {\n    key: \"HAHAH@#$%#@#@][\",\n    value: \"A\",\n    selected: layout === 'A'\n  }, \"Layout A\"), (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"option\", {\n    key: 1234,\n    value: \"B\",\n    selected: layout === 'B'\n  }, \"Layout B\")), (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {\n    style: {\n      marginTop: '100px'\n    }\n  }, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", null, \"Hi,\"), layout === 'A' && (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(null, null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(Wrapper, {\n    myRef: wrapperRef\n  }, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"b\", null, \"My\")), (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(null, null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(null, null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"i\", null, \"name\"), (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"span\", null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"u\", null, \"is\"))))), layout === 'B' && (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(null, null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"b\", null, \"I\"), (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(Wrapper, {\n    myRef: wrapperRef\n  }, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(null, null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"i\", null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(null, null, \"am\"))))), (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(Wrapper, null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(null, null, (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"a\", null, \"Quyet\")))));\n}\n\nfunction TimeEnd() {\n  console.timeEnd('mount');\n  return null;\n}\n\nfunction DemoFinalWrapper() {\n  return [(0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(DemoWrapperWrapper, null), (0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(TimeEnd, null)];\n}\n\nconsole.time('stack');\nconsole.time('mount');\n(0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.mount)((0,_output_dist_index_js__WEBPACK_IMPORTED_MODULE_0__.h)(DemoFinalWrapper, null), document.getElementById('sandbox-container'));\nconsole.timeEnd('stack');\n\n//# sourceURL=webpack://sandbox/./src/mount.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/mount.js");
/******/ 	
/******/ })()
;