/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ (function(module) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://docs/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://docs/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/contents/home/Home.js":
/*!***********************************!*\
  !*** ./src/contents/home/Home.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Home\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var _Home_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Home.less */ \"./src/contents/home/Home.less\");\n/* harmony import */ var core_pkg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core.pkg */ \"../lib/core/index.js\");\n\n\nvar Home = function Home() {\n  return (0,core_pkg__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    className: \"Home\"\n  }, (0,core_pkg__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"a\", {\n    className: \"logo\"\n  }, \"Fiddlehead\"));\n};\n\n//# sourceURL=webpack://docs/./src/contents/home/Home.js?");

/***/ }),

/***/ "./src/pages/index.js":
/*!****************************!*\
  !*** ./src/pages/index.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var core_pkg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core.pkg */ \"../lib/core/index.js\");\n/* harmony import */ var _contents_home_Home__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contents/home/Home */ \"./src/contents/home/Home.js\");\n\n\n(0,core_pkg__WEBPACK_IMPORTED_MODULE_0__.render)((0,core_pkg__WEBPACK_IMPORTED_MODULE_0__.jsx)(_contents_home_Home__WEBPACK_IMPORTED_MODULE_1__.Home, null), document.getElementById('root'));\n\n//# sourceURL=webpack://docs/./src/pages/index.js?");

/***/ }),

/***/ "../lib/core/cjs.development.js":
/*!**************************************!*\
  !*** ../lib/core/cjs.development.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n})); // Do not support namespace MathML as almost browsers do not support as well\n\nvar NAMESPACE_HTML = 0;\nvar NAMESPACE_SVG = 1; // Special node types\n\nvar TextNode = '#';\nvar Fragment = '[';\n\nvar Portal = function Portal(props) {\n  return props.children;\n};\n/**\n * \n * @param {function|string} type\n * @param {{}|string|null} props\n * @constructor\n */\n\n\nfunction VNode(type, props) {\n  // Identification\n  // ==============\n\n  /**\n   * @type {string|function}\n   */\n  this.type_ = type;\n  /**\n   * @type {string|null}\n   */\n\n  this.key_ = null;\n  /**\n   * @type {number|null}\n   */\n\n  this.slot_ = null; // Props and hooks\n  // ===============\n\n  /**\n   * @type {{}|string|null}\n   */\n\n  this.props_ = props;\n  /**\n   * @type {RefHook|null}\n   */\n\n  this.refHook_ = null;\n  /**\n   * @type {StateHook|null}\n   */\n\n  this.stateHook_ = null;\n  /**\n   * @type {EffectHook|null}\n   */\n\n  this.effectHook_ = null; // Output native node and relates\n  // ==============================\n\n  /**\n   * @type {Node}\n   */\n\n  this.nativeNode_ = null;\n  /**\n   * @type {string|null}\n   */\n\n  this.namespace_ = null;\n  /**\n   * @type {Ref|null}\n   */\n\n  this.ref_ = null; // Linked-list pointers\n  // ====================\n\n  /**\n   * @type {VNode|null}\n   */\n\n  this.parent_ = null;\n  /**\n   * @type {VNode|null}\n   */\n\n  this.child_ = null;\n  /**\n   * @type {VNode|null}\n   */\n\n  this.sibling_ = null; // Temporary properties\n  // ====================\n  // The previous version of this node\n\n  /**\n   * @type {VNode|null}\n   */\n\n  this.alternate_ = null; // The children (and their subtrees, of course) are marked to be deleted\n\n  /**\n   * @type {VNode[]|null}\n   */\n\n  this.deletions_ = null; // Insertion flag.\n  // To be used to optimize the painting process\n\n  /**\n   * @type {number|null}\n   */\n\n  this.insertion_ = null; // If this node is a mounting point, this property tracks the native child\n  // that will be used as the reference node to insert the new child after it\n\n  /**\n   * @type {Node|null}\n   */\n\n  this.mountingRef_ = null; // Timeout ID.\n  // After updating states, we need to re-render the subtree to display the up-to-date UI.\n  // But when we batching updates, we use this property to re-render only highest node\n  // which also needs re-rendering\n\n  /**\n   * @type {number|null}\n   */\n\n  this.updateId_ = null;\n}\n\nvar PROP_VNODE = '%vnode';\n/**\n * \n * @param {Node} nativeNode \n * @param {VNode} vnode \n */\n\nvar attachVNodeToNativeNode = function attachVNodeToNativeNode(nativeNode, vnode) {\n  nativeNode[PROP_VNODE] = vnode;\n};\n/**\n * \n * @param {Node} nativeNode \n * @returns {VNode|undefined}\n */\n\n\nvar extractVNodeFromNativeNode = function extractVNodeFromNativeNode(nativeNode) {\n  return nativeNode[PROP_VNODE];\n};\n/**\n * \n * @param {VNode} vnode \n * @param {Node} nativeNode\n */\n\n\nvar linkNativeNodeWithVNode = function linkNativeNodeWithVNode(vnode, nativeNode) {\n  vnode.nativeNode_ = nativeNode;\n\n  if (vnode.ref_ !== null) {\n    vnode.ref_.current = nativeNode;\n  }\n};\n/**\n * \n * @param {any} content \n * @param {Element} nativeNode\n * @constructor\n */\n\n\nfunction PortalElement(content, nativeNode) {\n  this.content_ = content;\n  this.nativeNode_ = nativeNode;\n}\n/**\n * \n * @param {any} content \n * @param {Element} nativeNode \n * @returns {PortalElement}\n */\n\n\nvar createPortal = function createPortal(content, nativeNode) {\n  return new PortalElement(content, nativeNode);\n};\n/**\n * \n * @param {PortalElement} element\n * @returns {VNode}\n */\n\n\nvar createVNodeFromPortalElement = function createVNodeFromPortalElement(element) {\n  var vnode = new VNode(Portal, {\n    children: element.content_\n  }); // Determine the namespace (we only support SVG and HTML namespaces)\n\n  vnode.namespace_ = 'ownerSVGElement' in element.nativeNode_ ? NAMESPACE_SVG : NAMESPACE_HTML;\n  linkNativeNodeWithVNode(vnode, element.nativeNode_); // Do not attach the vnode to the native node,\n  // Because many portals can share the same native node.\n\n  return vnode;\n}; // The mounting point is a virtual node which has a native node (not null)\n// It means that a mounting point can contains native children\n\n/**\n * \n * @param {VNode} current \n * @returns {VNode}\n */\n\n\nvar resolveMountingPoint = function resolveMountingPoint(current) {\n  while (true) {\n    if (current === null) {\n      return null;\n    }\n\n    if (current.nativeNode_ !== null) {\n      return current;\n    }\n\n    current = current.parent_;\n  }\n}; // Walk through native children of a parent\n\n/**\n * \n * @param {function} callback \n * @param {VNode} parent \n * @param {VNode?} stopBefore\n * @returns {void}\n */\n\n\nvar walkNativeChildren = function walkNativeChildren(callback, parent, stopBefore) {\n  var current = parent.child_;\n\n  if (current !== null) {\n    while (true) {\n      if (current === stopBefore) {\n        return;\n      }\n\n      if (current.nativeNode_ !== null) {\n        callback(current.nativeNode_);\n      } else if (current.child_ !== null) {\n        current = current.child_;\n        continue;\n      }\n\n      if (current === parent) {\n        return;\n      }\n\n      while (current.sibling_ === null) {\n        if (current.parent_ === null || current.parent_ === parent) {\n          return;\n        }\n\n        current = current.parent_;\n      }\n\n      current = current.sibling_;\n    }\n  }\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar slice = Array.prototype.slice;\n\nvar isString = function isString(value) {\n  return typeof value === 'string'\n  /* || value instanceof String*/\n  ;\n};\n\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number'\n  /* || value instanceof Number*/\n  ;\n};\n\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n\nvar isArray = function isArray(value) {\n  return value instanceof Array;\n};\n/**\n * \n * @param {Array} a \n * @param {Array} b \n * @returns {boolean}\n */\n\n\nvar compareArrays = function compareArrays(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = a.length - 1; i >= 0; --i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar updateNativeTextContent = function updateNativeTextContent(node, newText, oldText) {\n  if (newText !== oldText) {\n    node.textContent = newText;\n  }\n};\n\nvar updateNativeElementAttributes = function updateNativeElementAttributes(element, newAttributes, oldAttributes) {\n  _updateKeyValues(element, newAttributes, oldAttributes, _updateElementAttribute, _removeElementAttribute);\n};\n\nvar _updateElementAttribute = function _updateElementAttribute(element, attrName, newAttrValue, oldAttrValue) {\n  attrName = _normalizeElementAttributeName(attrName);\n\n  if (attrName === '') {\n    return;\n  }\n\n  if (attrName === 'style') {\n    _updateStyleProperties(element[attrName], newAttrValue, oldAttrValue);\n\n    return;\n  }\n\n  if (newAttrValue === oldAttrValue) {\n    return;\n  }\n\n  if (attrName in element) {\n    // Handles as properties first\n    try {\n      element[attrName] = newAttrValue;\n    } catch (x) {// Property may not writable\n    }\n  }\n\n  if (_canBeAttribute(attrName, newAttrValue)) {\n    element.setAttribute(attrName, newAttrValue);\n  }\n};\n\nvar _removeElementAttribute = function _removeElementAttribute(element, attrName, oldAttrValue) {\n  attrName = _normalizeElementAttributeName(attrName);\n\n  if (attrName === '') {\n    return;\n  }\n\n  if (attrName === 'style') {\n    _updateStyleProperties(element[attrName], null, oldAttrValue); // Clean up HTML code\n\n\n    element.removeAttribute(attrName);\n    return;\n  }\n\n  if (attrName in element) {\n    // Handles as properties first\n    try {\n      element[attrName] = null;\n    } catch (x) {// Property may not writable\n    }\n  }\n\n  if (_canBeAttribute(attrName, oldAttrValue)) {\n    element.removeAttribute(attrName);\n  }\n};\n\nvar _normalizeElementAttributeName = function _normalizeElementAttributeName(attrName) {\n  // Support React className\n  if (attrName === 'className') {\n    return 'class';\n  } // Support camelcase event listener bindings\n\n\n  if (attrName.length >= 4 && // at least 4 chars\n  attrName.charCodeAt(0) === 111 && // 1st char is o\n  attrName.charCodeAt(1) === 110 && // 2nd char is n\n  attrName.charCodeAt(2) <= 90 && attrName.charCodeAt(2) >= 65 // 3rd char is [A-Z]\n  ) {\n    return attrName.toLowerCase();\n  }\n\n  return attrName;\n};\n\nvar _canBeAttribute = function _canBeAttribute(name, value) {\n  if (name === 'innerHTML' || name === 'innerText' || name === 'textContent') {\n    return false;\n  }\n\n  if (!(isString(value) || isNumber(value))) {\n    return false;\n  }\n\n  return true;\n};\n\nvar _updateStyleProperties = function _updateStyleProperties(style, newProperties, oldProperties) {\n  _updateKeyValues(style, newProperties, oldProperties, _updateStyleProperty, _removeStyleProperty);\n};\n\nvar _updateStyleProperty = function _updateStyleProperty(style, propName, newPropValue) {\n  style[propName] = newPropValue;\n};\n\nvar _removeStyleProperty = function _removeStyleProperty(style, propName) {\n  style[propName] = '';\n};\n\nvar _updateKeyValues = function _updateKeyValues(target, newKeyValues, oldKeyValues, updateFn, removeFn) {\n  var oldEmpty = oldKeyValues == null; // is nullish\n\n  var newEmpty = newKeyValues == null; // is nullish\n\n  var key;\n\n  if (oldEmpty) {\n    if (newEmpty) ;else {\n      for (key in newKeyValues) {\n        if (_hasOwnNonEmpty(newKeyValues, key)) {\n          updateFn(target, key, newKeyValues[key]);\n        }\n      }\n    }\n  } else if (newEmpty) {\n    for (key in oldKeyValues) {\n      if (_hasOwnNonEmpty(oldKeyValues, key)) {\n        removeFn(target, key, oldKeyValues[key]);\n      }\n    }\n  } else {\n    for (key in oldKeyValues) {\n      if (_hasOwnNonEmpty(oldKeyValues, key)) {\n        if (_hasOwnNonEmpty(newKeyValues, key)) ;else {\n          removeFn(target, key, oldKeyValues[key]);\n        }\n      }\n    }\n\n    for (key in newKeyValues) {\n      if (_hasOwnNonEmpty(newKeyValues, key)) {\n        updateFn(target, key, newKeyValues[key], oldKeyValues[key]);\n      }\n    }\n  }\n};\n\nvar _hasOwnNonEmpty = function _hasOwnNonEmpty(target, prop) {\n  return hasOwnProperty.call(target, prop) && target[prop] != null // is not nulllish\n  ;\n};\n\nvar createNativeTextNode = function createNativeTextNode(text) {\n  return document.createTextNode(text);\n};\n\nvar createNativeElementWithNS = function createNativeElementWithNS(ns, type, attributes) {\n  var element = ns === NAMESPACE_SVG ? document.createElementNS('http://www.w3.org/2000/svg', type) : document.createElement(type);\n  updateNativeElementAttributes(element, attributes);\n  return element;\n};\n\nvar removeNativeNode = function removeNativeNode(nativeNode) {\n  if (nativeNode.parentNode !== null) {\n    nativeNode.parentNode.removeChild(nativeNode);\n  }\n};\n\nvar insertNativeNodeAfter = function insertNativeNodeAfter(parent, newChild, childBefore) {\n  parent.insertBefore(newChild, childBefore !== null ? childBefore.nextSibling : parent.firstChild);\n}; // Important!!!\n// This module does not handle Portal nodes\n\n\nvar hydrateView = function hydrateView(vnode) {\n  vnode.namespace_ = _determineNS(vnode); // Do nothing more with fragments\n\n  if (_isDry(vnode.type_)) {\n    return;\n  }\n\n  var nativeNode;\n\n  if (vnode.type_ === TextNode) {\n    nativeNode = createNativeTextNode(vnode.props_);\n  } else {\n    nativeNode = createNativeElementWithNS(vnode.namespace_, vnode.type_, vnode.props_);\n  }\n\n  linkNativeNodeWithVNode(vnode, nativeNode);\n\n  if (true) {\n    attachVNodeToNativeNode(nativeNode, vnode);\n  }\n};\n\nvar rehydrateView = function rehydrateView(newVNode, oldVNode) {\n  newVNode.namespace_ = _determineNS(newVNode); // Do nothing more with fragments\n\n  if (_isDry(newVNode.type_)) {\n    return;\n  } // Reuse the existing native node\n\n\n  linkNativeNodeWithVNode(newVNode, oldVNode.nativeNode_);\n\n  if (true) {\n    attachVNodeToNativeNode(oldVNode.nativeNode_, newVNode);\n  }\n\n  if (newVNode.type_ === TextNode) {\n    updateNativeTextContent(newVNode.nativeNode_, newVNode.props_, oldVNode.props_);\n  } else {\n    updateNativeElementAttributes(newVNode.nativeNode_, newVNode.props_, oldVNode.props_);\n  }\n}; // We only support HTML and SVG namespaces\n// as the most of browsers support\n\n\nvar _determineNS = function _determineNS(vnode) {\n  // Intrinsic namespace\n  if (vnode.type_ === 'svg') {\n    return NAMESPACE_SVG;\n  } // As we never hydrate the container node,\n  // the parent_ never empty here\n\n\n  if (vnode.parent_.namespace_ === NAMESPACE_SVG && vnode.parent_.type_ === 'foreignObject') {\n    return NAMESPACE_HTML;\n  } // By default, pass namespace below.\n\n\n  return vnode.parent_.namespace_;\n}; // Check if a node type cannot be hydrated\n\n\nvar _isDry = function _isDry(type) {\n  return type === Fragment || isFunction(type);\n}; // Important!!!\n// This module does not handle Portal nodes\n\n\nvar updateView = function updateView(newVNode, oldVNode) {\n  rehydrateView(newVNode, oldVNode);\n\n  if (newVNode.nativeNode_ !== null) {\n    var mpt = resolveMountingPoint(newVNode.parent_);\n\n    if (mpt !== null) {\n      mpt.mountingRef_ = newVNode.nativeNode_;\n    }\n  }\n};\n\nvar insertView = function insertView(vnode) {\n  if (vnode.nativeNode_ !== null) {\n    var mpt = resolveMountingPoint(vnode.parent_);\n\n    if (mpt !== null) {\n      insertNativeNodeAfter(mpt.nativeNode_, vnode.nativeNode_, mpt.mountingRef_);\n      mpt.mountingRef_ = vnode.nativeNode_;\n    }\n  }\n};\n\nvar deleteView = function deleteView(vnode) {\n  if (vnode.nativeNode_ !== null) {\n    removeNativeNode(vnode.nativeNode_);\n  } else {\n    walkNativeChildren(removeNativeNode, vnode);\n  }\n};\n\nvar currentVNode = null;\nvar currentRefHook = null;\nvar currentStateHook = null;\nvar currentEffectHook = null;\n\nvar prepareCurrentlyProcessing = function prepareCurrentlyProcessing(functionalVNode) {\n  currentVNode = functionalVNode;\n};\n\nvar flushCurrentlyProcessing = function flushCurrentlyProcessing() {\n  currentVNode = null;\n  currentRefHook = null;\n  currentStateHook = null;\n  currentEffectHook = null;\n};\n\nvar resolveRootVNode = function resolveRootVNode() {\n  _throwIfCallInvalid();\n\n  var vnode = currentVNode;\n\n  while (vnode.parent_ !== null) {\n    vnode = vnode.parent_;\n  }\n\n  return vnode;\n};\n\nvar resolveCurrentRefHook = function resolveCurrentRefHook(createHookFn, processFn) {\n  _throwIfCallInvalid();\n\n  currentRefHook = _resolveCurrentHookImpl(createHookFn, currentRefHook, currentVNode.refHook_);\n\n  if (currentVNode.refHook_ === null) {\n    currentVNode.refHook_ = currentRefHook;\n  }\n\n  return processFn(currentRefHook);\n};\n\nvar resolveCurrentStateHook = function resolveCurrentStateHook(createHookFn, processFn) {\n  _throwIfCallInvalid();\n\n  currentStateHook = _resolveCurrentHookImpl(createHookFn, currentStateHook, currentVNode.stateHook_);\n\n  if (currentVNode.stateHook_ === null) {\n    currentVNode.stateHook_ = currentStateHook;\n  }\n\n  return processFn(currentStateHook);\n};\n\nvar resolveCurrentEffectHook = function resolveCurrentEffectHook(createHookFn, processFn) {\n  _throwIfCallInvalid();\n\n  currentEffectHook = _resolveCurrentHookImpl(createHookFn, currentEffectHook, currentVNode.effectHook_);\n\n  if (currentVNode.effectHook_ === null) {\n    currentVNode.effectHook_ = currentEffectHook;\n  }\n\n  return processFn(currentEffectHook);\n};\n\nvar _resolveCurrentHookImpl = function _resolveCurrentHookImpl(createHookFn, currentHook, firstHookOfNode) {\n  if (currentHook === null) {\n    if (firstHookOfNode === null) {\n      return createHookFn(currentVNode);\n    } else {\n      return firstHookOfNode;\n    }\n  } else {\n    if (currentHook.next_ === null) {\n      var nextHook = createHookFn(currentVNode);\n      currentHook.next_ = nextHook;\n      return nextHook;\n    } else {\n      return currentHook.next_;\n    }\n  }\n};\n\nvar _throwIfCallInvalid = function _throwIfCallInvalid() {\n  if (currentVNode === null) {\n    throw new Error('Cannot use hooks from outside of components');\n  }\n};\n\nvar STATE_NORMAL = 0;\nvar STATE_ERROR = 1;\n/**\n *\n * @param {number} tag\n * @param {any} initialValue\n * @param {VNode} context\n * @constructor\n */\n\nfunction StateHook(tag, initialValue, context) {\n  this.tag_ = tag;\n  this.value_ = initialValue;\n  this.setValue_ = _setState.bind(this);\n  this.context_ = context;\n  this.next_ = null;\n}\n\nvar useState = function useState(initialValue) {\n  return resolveCurrentStateHook(function (currentVNode) {\n    return new StateHook(STATE_NORMAL, initialValue, currentVNode);\n  }, function (currentHook) {\n    return [currentHook.value_, currentHook.setValue_];\n  });\n};\n\nvar useError = function useError() {\n  return resolveCurrentStateHook(function (currentVNode) {\n    // Make sure we have only one error hook in a component\n    if (true) {\n      var hook = currentVNode.stateHook_;\n\n      while (hook !== null) {\n        if (hook.tag_ === STATE_ERROR) {\n          console.error('A component accepts only one useError hook');\n        }\n\n        hook = hook.next_;\n      }\n    }\n\n    return new StateHook(STATE_ERROR, null, currentVNode);\n  }, function (currentHook) {\n    return [currentHook.value_, function () {\n      currentHook.setValue_(null);\n    }];\n  });\n};\n\nvar _setState = function _setState(value) {\n  var newValue;\n\n  if (isFunction(value)) {\n    try {\n      newValue = value(this.value_);\n    } catch (error) {\n      catchError(error, this.context_);\n      return;\n    }\n  } else {\n    newValue = value;\n  }\n\n  if (this.value_ !== newValue) {\n    // Set value synchronously\n    this.value_ = newValue; // Schedule a work to update the UI\n\n    if (this.context_.updateId_ === null) {\n      this.context_.updateId_ = setTimeout(_flushUpdates, 0, this);\n    }\n  }\n};\n\nvar _flushUpdates = function _flushUpdates(hook) {\n  // Find the highest node also has pending updates\n  var highestContext = null;\n  var current = hook.context_;\n\n  while (current !== null) {\n    if (current.updateId_ !== null) {\n      highestContext = current;\n    }\n\n    current = current.parent_;\n  } // Re-render tree from the highest node\n\n\n  if (highestContext !== null) {\n    renderTree(highestContext);\n  }\n};\n\nvar catchError = function catchError(error, vnode) {\n  var parent = vnode.parent_;\n  var hook;\n\n  while (parent !== null) {\n    hook = parent.stateHook_;\n\n    while (hook !== null) {\n      if (hook.tag_ === STATE_ERROR) {\n        hook.setValue_(function (prevError) {\n          return prevError || error;\n        });\n        return;\n      }\n\n      hook = hook.next_;\n    }\n\n    parent = parent.parent_;\n  }\n\n  if (true) {\n    console.info('You can catch the following error by implementing an error boundary with the useError hook');\n  }\n\n  throw error;\n};\n\nvar EFFECT_NORMAL = 0;\nvar EFFECT_LAYOUT = 1;\n/**\n *\n * @param {number} tag\n * @param {function} callback\n * @param {[]|null} deps\n * @constructor\n */\n\nfunction EffectHook(tag, callback, deps) {\n  this.tag_ = tag;\n  this.callback_ = callback;\n  this.deps_ = deps;\n  this.destroy_ = null;\n  this.lastDeps_ = null;\n  this.next_ = null;\n}\n\nvar useEffect = function useEffect(callback, deps) {\n  return _useEffectImpl(EFFECT_NORMAL, callback, deps);\n};\n\nvar useLayoutEffect = function useLayoutEffect(callback, deps) {\n  return _useEffectImpl(EFFECT_LAYOUT, callback, deps);\n};\n\nvar _useEffectImpl = function _useEffectImpl(tag, callback, deps) {\n  if (deps === undefined) {\n    deps = null;\n  }\n\n  return resolveCurrentEffectHook(function (currentVNode) {\n    return new EffectHook(tag, callback, deps);\n  }, function (currentHook) {\n    if (true) {\n      if (!(deps === null && currentHook.deps_ === null || deps.length === currentHook.deps_.length)) {\n        throw new Error('Deps must be size-fixed');\n      } // On the production, we accept the deps change its length\n      // and consider it is changed\n\n    }\n\n    currentHook.callback_ = callback;\n    currentHook.deps_ = deps;\n  });\n};\n/**\n *\n * @param {number} effectTag\n * @param {VNode} vnode\n * @param {boolean} isNewlyMounted\n */\n\n\nvar mountEffects = function mountEffects(effectTag, vnode, isNewlyMounted) {\n  var hook = vnode.effectHook_;\n\n  while (hook !== null) {\n    if (hook.tag_ === effectTag) {\n      if (isNewlyMounted || _mismatchDeps(hook.deps_, hook.lastDeps_)) {\n        try {\n          _mountEffect(hook);\n        } catch (error) {\n          catchError(error, vnode);\n        }\n      }\n    }\n\n    hook = hook.next_;\n  }\n};\n/**\n * @param {number} effectTag\n * @param {VNode} vnode\n * @param {boolean} isUnmounted\n */\n\n\nvar destroyEffects = function destroyEffects(effectTag, vnode, isUnmounted) {\n  var hook = vnode.effectHook_;\n\n  while (hook !== null) {\n    if (hook.tag_ === effectTag) {\n      if (hook.destroy_ !== null) {\n        if (isUnmounted || _mismatchDeps(hook.deps_, hook.lastDeps_)) {\n          try {\n            hook.destroy_();\n          } catch (error) {\n            catchError(error, vnode);\n          }\n        }\n      }\n    }\n\n    hook = hook.next_;\n  }\n};\n/**\n *\n * @param {EffectHook} hook\n */\n\n\nvar _mountEffect = function _mountEffect(hook) {\n  // Save the last deps for the next time\n  hook.lastDeps_ = hook.deps_; // Run the effect callback\n\n  hook.destroy_ = hook.callback_();\n\n  if (hook.destroy_ === undefined) {\n    hook.destroy_ = null;\n  }\n};\n/**\n * \n * @param {[]|null} deps \n * @param {[]|null} lastDeps \n * @returns {boolean}\n */\n\n\nvar _mismatchDeps = function _mismatchDeps(deps, lastDeps) {\n  // Always\n  if (deps === null) {\n    return true;\n  } // Lazy\n\n\n  if (deps.length === 0) {\n    return false;\n  } // Deps\n  // 1. When init effect\n\n\n  if (lastDeps === null) {\n    return false;\n  } // 2. Two arrays are equal\n\n\n  if (compareArrays(deps, lastDeps)) {\n    return false;\n  } // DepsChanged\n\n\n  {\n    return true;\n  }\n};\n/**\n *\n * @param {any} current\n * @constructor\n */\n\n\nfunction Ref(current) {\n  this.current = current;\n}\n/**\n *\n * @param {any} current\n * @constructor\n */\n\n\nfunction RefHook(current) {\n  this.ref_ = new Ref(current);\n  this.next_ = null;\n}\n/**\n *\n * @param {any} initialValue\n */\n\n\nvar createRef = function createRef(initialValue) {\n  return new Ref(initialValue);\n};\n/**\n *\n * @param {any} initialValue\n */\n\n\nvar useRef = function useRef(initialValue) {\n  return resolveCurrentRefHook(function (currentVNode) {\n    return new RefHook(initialValue);\n  }, function (currentHook) {\n    return currentHook.ref_;\n  });\n};\n/**\n * \n * @param {VNode} current\n * @param {any[]} content\n */\n\n\nvar setChildrenFromContent = function setChildrenFromContent(current, content) {\n  var child,\n      prevChild = null,\n      i = 0;\n\n  for (; i < content.length; ++i) {\n    child = createVNodeFromContent(content[i]);\n\n    if (child !== null) {\n      child.parent_ = current;\n      child.slot_ = i;\n\n      if (prevChild !== null) {\n        prevChild.sibling_ = child;\n      } else {\n        current.child_ = child;\n      }\n\n      prevChild = child;\n    }\n  }\n};\n/**\n * \n * @param {VNode} current \n * @param {any} content\n */\n\n\nvar setOnlyChildFromContent = function setOnlyChildFromContent(current, content) {\n  var child = createVNodeFromContent(content);\n\n  if (child !== null) {\n    current.child_ = child;\n    child.parent_ = current; // Don't need to set the slot property\n    // as this node have only one child\n  }\n}; // Use the same empty object to save memory.\n// Do NOT mutate it\n\n\nvar emptyProps = {};\nObject.freeze(emptyProps);\n/**\n *\n * @param {string|function} type\n * @param {{}|null} props\n * @param {any} content\n * @constructor\n */\n\nfunction JSXElement(type, props, content) {\n  this.type_ = type;\n  this.props_ = props;\n  this.content_ = content;\n}\n/**\n * \n * @param {string|function} type\n * @param {{}|null} props\n * @param {any} content\n * @returns {JSXElement}\n */\n\n\nvar createElement = function createElement(type, props, content) {\n  if (arguments.length > 3) {\n    content = slice.call(arguments, 2);\n  }\n\n  return new JSXElement(type, props, content);\n};\n/**\n * \n * @param {JSXElement} element \n * @returns {VNode}\n */\n\n\nvar createVNodeFromJSXElement = function createVNodeFromJSXElement(element) {\n  // Type and content\n  var type = element.type_;\n  var content = element.content_;\n  var isFunctionalType = isFunction(type);\n  var hasContent = content !== undefined; // Resolve props\n\n  var props = element.props_;\n  var key = null;\n  var ref = null;\n\n  if (props === null) {\n    // Functional types always need the props to be an object\n    if (isFunctionalType) {\n      if (hasContent) {\n        props = {\n          children: content\n        };\n        Object.freeze(props);\n      } else {\n        props = emptyProps;\n      }\n    }\n  } else {\n    // Normalize key\n    // Accept any data type, except number (convert to string) and undefined\n    if (props.key !== undefined) {\n      if (isNumber(props.key)) {\n        key = '' + props.key;\n      } else {\n        key = props.key;\n      }\n\n      delete props.key;\n    } // Set children for functional types\n    // and set ref for static types.\n    // Allow functional types to access ref normally\n\n\n    if (isFunctionalType) {\n      if (hasContent) {\n        props.children = content;\n      }\n\n      Object.freeze(props);\n    } else {\n      if (props.ref !== undefined) {\n        if (props.ref instanceof Ref) {\n          ref = props.ref;\n        } else {\n          if (true) {\n            console.error('The ref property is invalid');\n          }\n        }\n\n        delete props.ref;\n      }\n    }\n  } // Initialize the node\n\n\n  var vnode = new VNode(type, props); // Set key and ref\n\n  vnode.key_ = key;\n  vnode.ref_ = ref; // Set children\n\n  if (hasContent) {\n    if (isFunctionalType) ;else if (type === TextNode) {\n      // Text nodes accept only one string as the child.\n      // Everything else will be converted to string\n      if (isString(content)) {\n        vnode.props_ = content;\n      } else {\n        vnode.props_ = '' + content;\n      }\n    } else {\n      // For fragments and HTML elements\n      if (isArray(content)) {\n        // Multiple children.\n        // If the only child is an array, treat its elements as the children of the node\n        setChildrenFromContent(vnode, content);\n      } else {\n        setOnlyChildFromContent(vnode, content);\n      }\n    }\n  }\n\n  return vnode;\n};\n/**\n *\n * @param {any} content\n * @return {VNode|null}\n */\n\n\nvar createVNodeFromContent = function createVNodeFromContent(content) {\n  if (content instanceof JSXElement) {\n    return createVNodeFromJSXElement(content);\n  }\n\n  if (isString(content)) {\n    return new VNode(TextNode, content);\n  }\n\n  if (isNumber(content)) {\n    return new VNode(TextNode, '' + content);\n  }\n\n  if (isArray(content)) {\n    var fragment = new VNode(Fragment, null);\n    setChildrenFromContent(fragment, content);\n    return fragment;\n  }\n\n  if (content instanceof PortalElement) {\n    return createVNodeFromPortalElement(content);\n  }\n\n  return null;\n};\n\nvar reconcileChildren = function reconcileChildren(current, isRenderRoot) {\n  if (isFunction(current.type_)) {\n    _reconcileOnlyChildOfDynamicNode(current, current.alternate_, isRenderRoot);\n  } else if (current.alternate_ !== null) {\n    _reconcileChildrenOfStaticNode(current, current.alternate_);\n  }\n};\n\nvar _reconcileOnlyChildOfDynamicNode = function _reconcileOnlyChildOfDynamicNode(current, alternate, isRenderRoot) {\n  if (alternate !== null) {\n    // Copy hooks\n    current.refHook_ = alternate.refHook_;\n    current.stateHook_ = alternate.stateHook_;\n    current.effectHook_ = alternate.effectHook_; // Update contexts of state hooks\n\n    var stateHook = current.stateHook_;\n\n    while (stateHook !== null) {\n      stateHook.context_ = current;\n      stateHook = stateHook.next_;\n    } // Transfer the update ID\n\n\n    current.updateId_ = alternate.updateId_;\n    alternate.updateId_ = null;\n  }\n\n  var newContent;\n  prepareCurrentlyProcessing(current);\n\n  try {\n    newContent = current.type_(current.props_);\n  } catch (error) {\n    catchError(error, current);\n    newContent = null;\n  }\n\n  flushCurrentlyProcessing();\n  var newChild = createVNodeFromContent(newContent);\n\n  if (newChild !== null) {\n    newChild.parent_ = current; // Don't need to set the slot property\n    // as a dynamic node can have only one child\n  }\n\n  var oldChild = isRenderRoot ? current.child_ : alternate !== null ? alternate.child_ : null;\n\n  if (oldChild !== null) {\n    if (newChild !== null && newChild.type_ === oldChild.type_ && newChild.key_ === oldChild.key_) {\n      _markAlternate(newChild, oldChild);\n    } else {\n      _addDeletion(current, oldChild);\n    }\n  }\n\n  current.child_ = newChild;\n};\n\nvar _reconcileChildrenOfStaticNode = function _reconcileChildrenOfStaticNode(current, alternate) {\n  var oldChildren = _mapChildren(alternate);\n\n  var newChildren = _mapChildren(current);\n\n  var newChild;\n  oldChildren.forEach(function (oldChild, mapKey) {\n    newChild = newChildren.get(mapKey);\n\n    if (newChild !== undefined && newChild.type_ === oldChild.type_) {\n      _markAlternate(newChild, oldChild);\n    } else {\n      _addDeletion(current, oldChild);\n    }\n  });\n};\n\nvar _markAlternate = function _markAlternate(newChild, oldChild) {\n  newChild.alternate_ = oldChild;\n};\n\nvar _addDeletion = function _addDeletion(current, childToDelete) {\n  if (current.deletions_ === null) {\n    current.deletions_ = [childToDelete];\n  } else {\n    current.deletions_.push(childToDelete);\n  }\n};\n\nvar _mapChildren = function _mapChildren(node) {\n  var map = new Map();\n  var child = node.child_;\n\n  while (child !== null) {\n    if (child.key_ !== null) {\n      map.set(child.key_, child);\n    } else {\n      map.set(child.slot_, child);\n    }\n\n    child = child.sibling_;\n  }\n\n  return map;\n};\n/**\n * \n * @param {VNode} current\n */\n\n\nvar renderTree = function renderTree(current) {\n  var effectMountNodes = new Map();\n  var effectDestroyNodes = new Map(); // The mounting point of the current\n\n  var mpt = resolveMountingPoint(current); // In the tree, the mounting point lies at a higher level\n  // than the current, so we need to initialize/cleanup\n  // its temporary properties from outside of the work loop\n\n  walkNativeChildren(function (nativeChild) {\n    mpt.mountingRef_ = nativeChild;\n  }, mpt, current); // Main work\n\n  _workLoop(_performUnitOfWork, _onReturn, current, effectMountNodes, effectDestroyNodes); // Cleanup\n\n\n  mpt.mountingRef_ = null; // Layout effects\n\n  effectDestroyNodes.forEach(function (isUnmounted, vnode) {\n    destroyEffects(EFFECT_LAYOUT, vnode, isUnmounted);\n  });\n  effectMountNodes.forEach(function (isNewlyMounted, vnode) {\n    mountEffects(EFFECT_LAYOUT, vnode, isNewlyMounted);\n  }); // Effects\n\n  setTimeout(function () {\n    effectDestroyNodes.forEach(function (isUnmounted, vnode) {\n      destroyEffects(EFFECT_NORMAL, vnode, isUnmounted);\n    });\n    effectMountNodes.forEach(function (isNewlyMounted, vnode) {\n      mountEffects(EFFECT_NORMAL, vnode, isNewlyMounted);\n    });\n  });\n}; // Optimize insertion to reduce reflow number\n\n\nvar INSERT_ON_RETURN = 0;\nvar INSERT_OFFSCREEN = 1;\n\nvar _performUnitOfWork = function _performUnitOfWork(current, root, effectMountNodes, effectDestroyNodes) {\n  var isRenderRoot = current === root; // Reconcile current's children\n\n  reconcileChildren(current, isRenderRoot); // Portal nodes never change the view itself\n\n  if (current.type_ !== Portal) {\n    if (isRenderRoot) {\n      if (current.effectHook_ !== null) {\n        effectDestroyNodes.set(current, false);\n        effectMountNodes.set(current, false);\n      }\n    } else {\n      if (current.alternate_ !== null) {\n        updateView(current, current.alternate_);\n\n        if (current.effectHook_ !== null) {\n          effectDestroyNodes.set(current.alternate_, false);\n          effectMountNodes.set(current, false);\n        }\n\n        current.alternate_ = null;\n      } else {\n        hydrateView(current);\n\n        if (current.child_ !== null) {\n          // We always have parent here, because\n          // this area is under the render root\n          if (current.parent_.insertion_ !== null) {\n            current.insertion_ = INSERT_OFFSCREEN;\n            insertView(current);\n          } else {\n            // Insert-on-return nodes must have a native node!\n            if (current.nativeNode_ !== null) {\n              current.insertion_ = INSERT_ON_RETURN;\n            }\n          }\n        } else {\n          insertView(current);\n        }\n\n        if (current.effectHook_ !== null) {\n          effectMountNodes.set(current, true);\n        }\n      }\n    }\n  } // Delete subtrees that no longer exist\n\n\n  if (current.deletions_ !== null) {\n    for (var i = 0; i < current.deletions_.length; ++i) {\n      deleteView(current.deletions_[i]);\n\n      _workLoop(function (deleted) {\n        if (deleted.effectHook_ !== null) {\n          effectDestroyNodes.set(deleted, true);\n        } // Important!!!\n        // Cancel the update schedule on the deleted nodes\n\n\n        if (deleted.updateId_ !== null) {\n          clearTimeout(deleted.updateId_);\n          deleted.updateId_ = null;\n        }\n      }, null, current.deletions_[i]);\n    }\n\n    current.deletions_ = null;\n  } // Cancel the update schedule on the current node\n\n\n  if (current.updateId_ !== null) {\n    clearTimeout(current.updateId_);\n    current.updateId_ = null;\n  }\n}; // Callback called after walking through a node and all of its ascendants\n\n\nvar _onReturn = function _onReturn(current) {\n  // Process the insert-on-return node before walk out of its subtree\n  if (current.insertion_ === INSERT_ON_RETURN) {\n    insertView(current);\n  } // This is when we cleanup the remaining temporary properties\n\n\n  current.mountingRef_ = null;\n  current.insertion_ = null;\n}; // Reference: https://github.com/facebook/react/issues/7942\n\n\nvar _workLoop = function _workLoop(performUnit, onReturn, root, D0, D1) {\n  var current = root;\n\n  while (true) {\n    performUnit(current, root, D0, D1);\n\n    if (current.child_ !== null) {\n      current = current.child_;\n      continue;\n    }\n\n    if (current === root) {\n      return;\n    }\n\n    while (current.sibling_ === null) {\n      if (current.parent_ === null || current.parent_ === root) {\n        return;\n      }\n\n      current = current.parent_;\n\n      if (onReturn !== null) {\n        onReturn(current);\n      }\n    }\n\n    current = current.sibling_;\n  }\n};\n/**\n * \n * @param {any} children \n * @param {Element} targetNativeNode\n */\n\n\nvar render = function render(children, targetNativeNode) {\n  var root = extractVNodeFromNativeNode(targetNativeNode);\n\n  if (root) {\n    // Update the children\n    root.props_.children = children;\n  } else {\n    // Create a new root\n    if (true) {\n      if (targetNativeNode.firstChild) {\n        console.error('Target node must be empty');\n      }\n    }\n\n    var portalElement = createPortal(children, targetNativeNode);\n    root = createVNodeFromPortalElement(portalElement);\n    attachVNodeToNativeNode(targetNativeNode, root);\n  }\n\n  renderTree(root);\n};\n\nexports.Fragment = Fragment;\nexports.TextNode = TextNode;\nexports.createElement = createElement;\nexports.createPortal = createPortal;\nexports.createRef = createRef;\nexports.jsx = createElement;\nexports.render = render;\nexports.resolveRootVNode = resolveRootVNode;\nexports.useEffect = useEffect;\nexports.useError = useError;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useRef = useRef;\nexports.useState = useState;\n\n//# sourceURL=webpack://docs/../lib/core/cjs.development.js?");

/***/ }),

/***/ "../lib/core/index.js":
/*!****************************!*\
  !*** ../lib/core/index.js ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("if (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs.development.js */ \"../lib/core/cjs.development.js\");\n}\n\n//# sourceURL=webpack://docs/../lib/core/index.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/less-loader/dist/cjs.js!./src/contents/home/Home.less":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/less-loader/dist/cjs.js!./src/contents/home/Home.less ***!
  \****************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Home .logo {\\n  font-weight: bold;\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://docs/./src/contents/home/Home.less?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet%5B1%5D.rules%5B1%5D.use%5B2%5D!./node_modules/less-loader/dist/cjs.js");

/***/ }),

/***/ "./src/contents/home/Home.less":
/*!*************************************!*\
  !*** ./src/contents/home/Home.less ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/singletonStyleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/singletonStyleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_less_loader_dist_cjs_js_Home_less__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!../../../node_modules/less-loader/dist/cjs.js!./Home.less */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].use[2]!./node_modules/less-loader/dist/cjs.js!./src/contents/home/Home.less\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\n;\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_less_loader_dist_cjs_js_Home_less__WEBPACK_IMPORTED_MODULE_5__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_less_loader_dist_cjs_js_Home_less__WEBPACK_IMPORTED_MODULE_5__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_less_loader_dist_cjs_js_Home_less__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_use_2_node_modules_less_loader_dist_cjs_js_Home_less__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://docs/./src/contents/home/Home.less?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://docs/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://docs/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://docs/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://docs/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/singletonStyleDomAPI.js":
/*!************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/singletonStyleDomAPI.js ***!
  \************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n\n/* istanbul ignore next  */\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join(\"\\n\");\n  };\n}();\n/* istanbul ignore next  */\n\n\nfunction apply(styleElement, index, remove, obj) {\n  var css;\n\n  if (remove) {\n    css = \"\";\n  } else {\n    css = \"\";\n\n    if (obj.supports) {\n      css += \"@supports (\".concat(obj.supports, \") {\");\n    }\n\n    if (obj.media) {\n      css += \"@media \".concat(obj.media, \" {\");\n    }\n\n    var needLayer = typeof obj.layer !== \"undefined\";\n\n    if (needLayer) {\n      css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n    }\n\n    css += obj.css;\n\n    if (needLayer) {\n      css += \"}\";\n    }\n\n    if (obj.media) {\n      css += \"}\";\n    }\n\n    if (obj.supports) {\n      css += \"}\";\n    }\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = styleElement.childNodes;\n\n    if (childNodes[index]) {\n      styleElement.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index]);\n    } else {\n      styleElement.appendChild(cssNode);\n    }\n  }\n}\n\nvar singletonData = {\n  singleton: null,\n  singletonCounter: 0\n};\n/* istanbul ignore next  */\n\nfunction domAPI(options) {\n  // eslint-disable-next-line no-undef,no-use-before-define\n  var styleIndex = singletonData.singletonCounter++;\n  var styleElement = // eslint-disable-next-line no-undef,no-use-before-define\n  singletonData.singleton || ( // eslint-disable-next-line no-undef,no-use-before-define\n  singletonData.singleton = options.insertStyleElement(options));\n  return {\n    update: function update(obj) {\n      apply(styleElement, styleIndex, false, obj);\n    },\n    remove: function remove(obj) {\n      apply(styleElement, styleIndex, true, obj);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://docs/./node_modules/style-loader/dist/runtime/singletonStyleDomAPI.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	!function() {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/pages/index.js");
/******/ 	
/******/ })()
;